// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `extract_app_path_from_conditions`, `parse_filter_info`, `string_to_wide`, `wide_to_string`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `drop`, `fmt`, `fmt`, `fmt`, `fmt`

/// 创建WFP管理器实例
///
/// # 返回值
/// * `Result<WfpManager>` - 成功返回WfpManager实例，失败返回错误
///
/// # 示例
/// ```rust
/// let wfp_manager = create_wfp_manager()?;
/// ```
Future<WfpManager> createWfpManager() =>
    RustLib.instance.api.crateApiWfpCreateWfpManager();

/// 为应用程序添加阻止规则的便捷函数
///
/// # 参数
/// * `app_path` - 应用程序路径
/// * `direction` - 流量方向
/// * `rule_name` - 规则名称
///
/// # 返回值
/// * `Result<u64>` - 成功返回过滤器ID，失败返回错误
///
/// # 示例
/// ```rust
/// let filter_id = block_app_traffic(
///     "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
///     TrafficDirection::Outbound,
///     "阻止Chrome出站连接"
/// )?;
/// ```
Future<BigInt> blockAppTraffic({
  required String appPath,
  required TrafficDirection direction,
  required String ruleName,
}) => RustLib.instance.api.crateApiWfpBlockAppTraffic(
  appPath: appPath,
  direction: direction,
  ruleName: ruleName,
);

/// 为应用程序添加允许规则的便捷函数
///
/// # 参数
/// * `app_path` - 应用程序路径
/// * `direction` - 流量方向
/// * `rule_name` - 规则名称
///
/// # 返回值
/// * `Result<u64>` - 成功返回过滤器ID，失败返回错误
///
/// # 示例
/// ```rust
/// let filter_id = allow_app_traffic(
///     "C:\\Program Files\\MyApp\\myapp.exe",
///     TrafficDirection::Both,
///     "允许MyApp网络访问"
/// )?;
/// ```
Future<BigInt> allowAppTraffic({
  required String appPath,
  required TrafficDirection direction,
  required String ruleName,
}) => RustLib.instance.api.crateApiWfpAllowAppTraffic(
  appPath: appPath,
  direction: direction,
  ruleName: ruleName,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WfpManager>>
abstract class WfpManager implements RustOpaqueInterface {
  /// 为指定应用程序添加过滤规则
  ///
  /// # 参数
  /// * `rule` - 应用程序过滤规则
  ///
  /// # 返回值
  /// * `Result<u64>` - 成功返回过滤器ID，失败返回错误
  ///
  /// # 示例
  /// ```rust
  /// let rule = AppFilterRule {
  ///     name: "Block Chrome Outbound".to_string(),
  ///     app_path: "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe".to_string(),
  ///     direction: TrafficDirection::Outbound,
  ///     action: FilterAction::Block,
  ///     enabled: true,
  ///     description: Some("阻止Chrome的出站连接".to_string()),
  /// };
  /// let filter_id = wfp_manager.add_app_filter(&rule)?;
  /// ```
  Future<BigInt> addAppFilter({required AppFilterRule rule});

  /// 清除指定应用程序的所有过滤规则
  ///
  /// # 参数
  /// * `app_path` - 应用程序路径
  ///
  /// # 返回值
  /// * `Result<u32>` - 成功返回清除的规则数量，失败返回错误
  ///
  /// # 示例
  /// ```rust
  /// let removed_count = wfp_manager.clear_app_filters(
  ///     "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"
  /// )?;
  /// println!("已清除 {} 条规则", removed_count);
  /// ```
  Future<int> clearAppFilters({required String appPath});

  /// 检查指定应用程序是否被阻止
  ///
  /// # 参数
  /// * `app_path` - 应用程序路径
  /// * `direction` - 流量方向
  ///
  /// # 返回值
  /// * `Result<bool>` - 成功返回是否被阻止，失败返回错误
  ///
  /// # 示例
  /// ```rust
  /// let is_blocked = wfp_manager.is_app_blocked(
  ///     "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
  ///     &TrafficDirection::Outbound
  /// )?;
  /// ```
  Future<bool> isAppBlocked({
    required String appPath,
    required TrafficDirection direction,
  });

  /// 获取所有应用程序过滤器列表
  ///
  /// # 返回值
  /// * `Result<Vec<WfpFilterInfo>>` - 成功返回过滤器信息列表，失败返回错误
  ///
  /// # 示例
  /// ```rust
  /// let filters = wfp_manager.list_app_filters()?;
  /// for filter in filters {
  ///     println!("过滤器: {} - {}", filter.name, filter.app_path);
  /// }
  /// ```
  Future<List<WfpFilterInfo>> listAppFilters();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// 创建新的WFP管理器实例
  ///
  /// # 返回值
  /// * `Result<Self>` - 成功返回WfpManager实例，失败返回错误
  ///
  /// # 示例
  /// ```rust
  /// let wfp_manager = WfpManager::new()?;
  /// ```
  static Future<WfpManager> newInstance() =>
      RustLib.instance.api.crateApiWfpWfpManagerNew();

  /// 移除指定的过滤器
  ///
  /// # 参数
  /// * `filter_id` - 过滤器ID
  ///
  /// # 返回值
  /// * `Result<()>` - 成功返回()，失败返回错误
  ///
  /// # 示例
  /// ```rust
  /// wfp_manager.remove_filter(filter_id)?;
  /// ```
  Future<void> removeFilter({required BigInt filterId});
}

/// 应用程序过滤规则
class AppFilterRule {
  /// 规则名称
  final String name;

  /// 应用程序路径
  final String appPath;

  /// 流量方向
  final TrafficDirection direction;

  /// 过滤动作
  final FilterAction action;

  /// 是否启用
  final bool enabled;

  /// 规则描述
  final String? description;

  const AppFilterRule({
    required this.name,
    required this.appPath,
    required this.direction,
    required this.action,
    required this.enabled,
    this.description,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      appPath.hashCode ^
      direction.hashCode ^
      action.hashCode ^
      enabled.hashCode ^
      description.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppFilterRule &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          appPath == other.appPath &&
          direction == other.direction &&
          action == other.action &&
          enabled == other.enabled &&
          description == other.description;
}

/// 过滤器动作枚举
enum FilterAction {
  /// 允许通过
  allow,

  /// 阻止通过
  block,
}

/// 网络流量方向枚举
enum TrafficDirection {
  /// 入站流量
  inbound,

  /// 出站流量
  outbound,

  /// 双向流量
  both,
}

/// WFP过滤器信息
class WfpFilterInfo {
  /// 过滤器ID
  final BigInt filterId;

  /// 过滤器名称
  final String name;

  /// 应用程序路径
  final String appPath;

  /// 流量方向
  final TrafficDirection direction;

  /// 过滤动作
  final FilterAction action;

  /// 权重（优先级）
  final BigInt weight;

  const WfpFilterInfo({
    required this.filterId,
    required this.name,
    required this.appPath,
    required this.direction,
    required this.action,
    required this.weight,
  });

  @override
  int get hashCode =>
      filterId.hashCode ^
      name.hashCode ^
      appPath.hashCode ^
      direction.hashCode ^
      action.hashCode ^
      weight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WfpFilterInfo &&
          runtimeType == other.runtimeType &&
          filterId == other.filterId &&
          name == other.name &&
          appPath == other.appPath &&
          direction == other.direction &&
          action == other.action &&
          weight == other.weight;
}
