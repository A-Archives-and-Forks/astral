// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `create_and_store_network_instance`, `create_config`, `graceful_shutdown`, `setup_control_handler`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `RT`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `deref`, `initialize`

Future<(List<PeerInfo>, List<Route>)> getPeersAndRoutes() =>
    RustLib.instance.api.crateApiSimpleGetPeersAndRoutes();

Future<List<PeerRoutePair>> getPeerRoutePairs() =>
    RustLib.instance.api.crateApiSimpleGetPeerRoutePairs();

Future<MyNodeInfo> getNodeInfo() =>
    RustLib.instance.api.crateApiSimpleGetNodeInfo();

Future<String> easytierVersion() =>
    RustLib.instance.api.crateApiSimpleEasytierVersion();

Future<bool> isEasytierRunning() =>
    RustLib.instance.api.crateApiSimpleIsEasytierRunning();

Future<List<String>> getAllIps() =>
    RustLib.instance.api.crateApiSimpleGetAllIps();

Future<void> setTunFd({required int fd}) =>
    RustLib.instance.api.crateApiSimpleSetTunFd(fd: fd);

Future<KVNetworkStatus> getNetworkStatus() =>
    RustLib.instance.api.crateApiSimpleGetNetworkStatus();

Future<String> getRunningInfo() =>
    RustLib.instance.api.crateApiSimpleGetRunningInfo();

Future<void> createServer(
        {required String username,
        required bool enableDhcp,
        required String specifiedIp,
        required String roomName,
        required String roomPassword,
        required List<String> severurl,
        required FlagsC flag}) =>
    RustLib.instance.api.crateApiSimpleCreateServer(
        username: username,
        enableDhcp: enableDhcp,
        specifiedIp: specifiedIp,
        roomName: roomName,
        roomPassword: roomPassword,
        severurl: severurl,
        flag: flag);

Future<void> closeAllServer() =>
    RustLib.instance.api.crateApiSimpleCloseAllServer();

Future<NetworkInterfaceHops> getNetworkInterfaceHops() =>
    RustLib.instance.api.crateApiSimpleGetNetworkInterfaceHops();

Future<bool> setNetworkInterfaceHops({required int hop}) =>
    RustLib.instance.api.crateApiSimpleSetNetworkInterfaceHops(hop: hop);

Future<void> initApp() => RustLib.instance.api.crateApiSimpleInitApp();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MyNodeInfo>>
abstract class MyNodeInfo implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerInfo>>
abstract class PeerInfo implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerRoutePair>>
abstract class PeerRoutePair implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Route>>
abstract class Route implements RustOpaqueInterface {}

class FlagsC {
  final String defaultProtocol;
  final String devName;
  final bool enableEncryption;
  final bool enableIpv6;
  final int mtu;
  final bool latencyFirst;
  final bool enableExitNode;
  final bool noTun;
  final bool useSmoltcp;
  final String relayNetworkWhitelist;
  final bool disableP2P;
  final bool relayAllPeerRpc;
  final bool disableUdpHolePunching;

  /// string ipv6_listener = 14; \[deprecated = true\]; use -l udp://\[::\]:12345 instead
  final bool multiThread;
  final int dataCompressAlgo;
  final bool bindDevice;
  final bool enableKcpProxy;
  final bool disableKcpInput;
  final bool disableRelayKcp;
  final bool proxyForwardBySystem;

  const FlagsC({
    required this.defaultProtocol,
    required this.devName,
    required this.enableEncryption,
    required this.enableIpv6,
    required this.mtu,
    required this.latencyFirst,
    required this.enableExitNode,
    required this.noTun,
    required this.useSmoltcp,
    required this.relayNetworkWhitelist,
    required this.disableP2P,
    required this.relayAllPeerRpc,
    required this.disableUdpHolePunching,
    required this.multiThread,
    required this.dataCompressAlgo,
    required this.bindDevice,
    required this.enableKcpProxy,
    required this.disableKcpInput,
    required this.disableRelayKcp,
    required this.proxyForwardBySystem,
  });

  @override
  int get hashCode =>
      defaultProtocol.hashCode ^
      devName.hashCode ^
      enableEncryption.hashCode ^
      enableIpv6.hashCode ^
      mtu.hashCode ^
      latencyFirst.hashCode ^
      enableExitNode.hashCode ^
      noTun.hashCode ^
      useSmoltcp.hashCode ^
      relayNetworkWhitelist.hashCode ^
      disableP2P.hashCode ^
      relayAllPeerRpc.hashCode ^
      disableUdpHolePunching.hashCode ^
      multiThread.hashCode ^
      dataCompressAlgo.hashCode ^
      bindDevice.hashCode ^
      enableKcpProxy.hashCode ^
      disableKcpInput.hashCode ^
      disableRelayKcp.hashCode ^
      proxyForwardBySystem.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlagsC &&
          runtimeType == other.runtimeType &&
          defaultProtocol == other.defaultProtocol &&
          devName == other.devName &&
          enableEncryption == other.enableEncryption &&
          enableIpv6 == other.enableIpv6 &&
          mtu == other.mtu &&
          latencyFirst == other.latencyFirst &&
          enableExitNode == other.enableExitNode &&
          noTun == other.noTun &&
          useSmoltcp == other.useSmoltcp &&
          relayNetworkWhitelist == other.relayNetworkWhitelist &&
          disableP2P == other.disableP2P &&
          relayAllPeerRpc == other.relayAllPeerRpc &&
          disableUdpHolePunching == other.disableUdpHolePunching &&
          multiThread == other.multiThread &&
          dataCompressAlgo == other.dataCompressAlgo &&
          bindDevice == other.bindDevice &&
          enableKcpProxy == other.enableKcpProxy &&
          disableKcpInput == other.disableKcpInput &&
          disableRelayKcp == other.disableRelayKcp &&
          proxyForwardBySystem == other.proxyForwardBySystem;
}

class KVNetworkStatus {
  final BigInt totalNodes;
  final List<KVNodeInfo> nodes;

  const KVNetworkStatus({
    required this.totalNodes,
    required this.nodes,
  });

  @override
  int get hashCode => totalNodes.hashCode ^ nodes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KVNetworkStatus &&
          runtimeType == other.runtimeType &&
          totalNodes == other.totalNodes &&
          nodes == other.nodes;
}

class KVNodeConnectionStats {
  final String connType;
  final BigInt rxBytes;
  final BigInt txBytes;
  final BigInt rxPackets;
  final BigInt txPackets;

  const KVNodeConnectionStats({
    required this.connType,
    required this.rxBytes,
    required this.txBytes,
    required this.rxPackets,
    required this.txPackets,
  });

  @override
  int get hashCode =>
      connType.hashCode ^
      rxBytes.hashCode ^
      txBytes.hashCode ^
      rxPackets.hashCode ^
      txPackets.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KVNodeConnectionStats &&
          runtimeType == other.runtimeType &&
          connType == other.connType &&
          rxBytes == other.rxBytes &&
          txBytes == other.txBytes &&
          rxPackets == other.rxPackets &&
          txPackets == other.txPackets;
}

class KVNodeInfo {
  final String hostname;
  final String ipv4;
  final double latencyMs;
  final String nat;
  final List<NodeHopStats> hops;
  final double lossRate;
  final List<KVNodeConnectionStats> connections;
  final String version;
  final int cost;

  const KVNodeInfo({
    required this.hostname,
    required this.ipv4,
    required this.latencyMs,
    required this.nat,
    required this.hops,
    required this.lossRate,
    required this.connections,
    required this.version,
    required this.cost,
  });

  @override
  int get hashCode =>
      hostname.hashCode ^
      ipv4.hashCode ^
      latencyMs.hashCode ^
      nat.hashCode ^
      hops.hashCode ^
      lossRate.hashCode ^
      connections.hashCode ^
      version.hashCode ^
      cost.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KVNodeInfo &&
          runtimeType == other.runtimeType &&
          hostname == other.hostname &&
          ipv4 == other.ipv4 &&
          latencyMs == other.latencyMs &&
          nat == other.nat &&
          hops == other.hops &&
          lossRate == other.lossRate &&
          connections == other.connections &&
          version == other.version &&
          cost == other.cost;
}

class NetworkInterfaceHop {
  final String interfaceName;
  final int hopCount;

  const NetworkInterfaceHop({
    required this.interfaceName,
    required this.hopCount,
  });

  @override
  int get hashCode => interfaceName.hashCode ^ hopCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkInterfaceHop &&
          runtimeType == other.runtimeType &&
          interfaceName == other.interfaceName &&
          hopCount == other.hopCount;
}

class NetworkInterfaceHops {
  final List<NetworkInterfaceHop> hops;

  const NetworkInterfaceHops({
    required this.hops,
  });

  @override
  int get hashCode => hops.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkInterfaceHops &&
          runtimeType == other.runtimeType &&
          hops == other.hops;
}

class NodeHopStats {
  final String targetIp;
  final double latencyMs;
  final double packetLoss;
  final String nodeName;

  const NodeHopStats({
    required this.targetIp,
    required this.latencyMs,
    required this.packetLoss,
    required this.nodeName,
  });

  @override
  int get hashCode =>
      targetIp.hashCode ^
      latencyMs.hashCode ^
      packetLoss.hashCode ^
      nodeName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeHopStats &&
          runtimeType == other.runtimeType &&
          targetIp == other.targetIp &&
          latencyMs == other.latencyMs &&
          packetLoss == other.packetLoss &&
          nodeName == other.nodeName;
}
