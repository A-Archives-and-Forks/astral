// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `create_and_store_network_instance`, `create_config`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `KVNetworkStatus`, `KVNodeConnectionStats`, `KVNodeInfo`, `NodeHopStats`, `RT`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `deref`, `initialize`

Future<(List<PeerInfo>, List<Route>)> getPeersAndRoutes() =>
    RustLib.instance.api.crateApiSimpleGetPeersAndRoutes();

Future<List<PeerRoutePair>> getPeerRoutePairs() =>
    RustLib.instance.api.crateApiSimpleGetPeerRoutePairs();

Future<MyNodeInfo> getNodeInfo() =>
    RustLib.instance.api.crateApiSimpleGetNodeInfo();

Future<String> easytierVersion() =>
    RustLib.instance.api.crateApiSimpleEasytierVersion();

Future<bool> isEasytierRunning() =>
    RustLib.instance.api.crateApiSimpleIsEasytierRunning();

Future<List<String>> getAllIps() =>
    RustLib.instance.api.crateApiSimpleGetAllIps();

Future<void> setTunFd({required int fd}) =>
    RustLib.instance.api.crateApiSimpleSetTunFd(fd: fd);

Future<String> getRunningInfo() =>
    RustLib.instance.api.crateApiSimpleGetRunningInfo();

Future<void> createServer({
  required String username,
  required bool enableDhcp,
  required String specifiedIp,
  required String roomName,
  required String roomPassword,
  required List<String> severurl,
  required List<String> onurl,
  required FlagsC flag,
}) => RustLib.instance.api.crateApiSimpleCreateServer(
  username: username,
  enableDhcp: enableDhcp,
  specifiedIp: specifiedIp,
  roomName: roomName,
  roomPassword: roomPassword,
  severurl: severurl,
  onurl: onurl,
  flag: flag,
);

Future<void> closeAllServer() =>
    RustLib.instance.api.crateApiSimpleCloseAllServer();

Future<NetworkInterfaceHops> getNetworkInterfaceHops() =>
    RustLib.instance.api.crateApiSimpleGetNetworkInterfaceHops();

Future<bool> setNetworkInterfaceHops({required int hop}) =>
    RustLib.instance.api.crateApiSimpleSetNetworkInterfaceHops(hop: hop);

Future<void> initApp() => RustLib.instance.api.crateApiSimpleInitApp();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MyNodeInfo>>
abstract class MyNodeInfo implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerInfo>>
abstract class PeerInfo implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerRoutePair>>
abstract class PeerRoutePair implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Route>>
abstract class Route implements RustOpaqueInterface {}

class FlagsC {
  final String defaultProtocol;
  final String devName;
  final bool enableEncryption;
  final bool enableIpv6;
  final int mtu;
  final bool latencyFirst;
  final bool enableExitNode;
  final bool noTun;
  final bool useSmoltcp;
  final String relayNetworkWhitelist;
  final bool disableP2P;
  final bool relayAllPeerRpc;
  final bool disableUdpHolePunching;

  /// string ipv6_listener = 14; \[deprecated = true\]; use -l udp://\[::\]:12345 instead
  final bool multiThread;
  final int dataCompressAlgo;
  final bool bindDevice;
  final bool enableKcpProxy;
  final bool disableKcpInput;
  final bool disableRelayKcp;
  final bool proxyForwardBySystem;

  const FlagsC({
    required this.defaultProtocol,
    required this.devName,
    required this.enableEncryption,
    required this.enableIpv6,
    required this.mtu,
    required this.latencyFirst,
    required this.enableExitNode,
    required this.noTun,
    required this.useSmoltcp,
    required this.relayNetworkWhitelist,
    required this.disableP2P,
    required this.relayAllPeerRpc,
    required this.disableUdpHolePunching,
    required this.multiThread,
    required this.dataCompressAlgo,
    required this.bindDevice,
    required this.enableKcpProxy,
    required this.disableKcpInput,
    required this.disableRelayKcp,
    required this.proxyForwardBySystem,
  });

  @override
  int get hashCode =>
      defaultProtocol.hashCode ^
      devName.hashCode ^
      enableEncryption.hashCode ^
      enableIpv6.hashCode ^
      mtu.hashCode ^
      latencyFirst.hashCode ^
      enableExitNode.hashCode ^
      noTun.hashCode ^
      useSmoltcp.hashCode ^
      relayNetworkWhitelist.hashCode ^
      disableP2P.hashCode ^
      relayAllPeerRpc.hashCode ^
      disableUdpHolePunching.hashCode ^
      multiThread.hashCode ^
      dataCompressAlgo.hashCode ^
      bindDevice.hashCode ^
      enableKcpProxy.hashCode ^
      disableKcpInput.hashCode ^
      disableRelayKcp.hashCode ^
      proxyForwardBySystem.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlagsC &&
          runtimeType == other.runtimeType &&
          defaultProtocol == other.defaultProtocol &&
          devName == other.devName &&
          enableEncryption == other.enableEncryption &&
          enableIpv6 == other.enableIpv6 &&
          mtu == other.mtu &&
          latencyFirst == other.latencyFirst &&
          enableExitNode == other.enableExitNode &&
          noTun == other.noTun &&
          useSmoltcp == other.useSmoltcp &&
          relayNetworkWhitelist == other.relayNetworkWhitelist &&
          disableP2P == other.disableP2P &&
          relayAllPeerRpc == other.relayAllPeerRpc &&
          disableUdpHolePunching == other.disableUdpHolePunching &&
          multiThread == other.multiThread &&
          dataCompressAlgo == other.dataCompressAlgo &&
          bindDevice == other.bindDevice &&
          enableKcpProxy == other.enableKcpProxy &&
          disableKcpInput == other.disableKcpInput &&
          disableRelayKcp == other.disableRelayKcp &&
          proxyForwardBySystem == other.proxyForwardBySystem;
}

class NetworkInterfaceHop {
  final String interfaceName;
  final int hopCount;

  const NetworkInterfaceHop({
    required this.interfaceName,
    required this.hopCount,
  });

  @override
  int get hashCode => interfaceName.hashCode ^ hopCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkInterfaceHop &&
          runtimeType == other.runtimeType &&
          interfaceName == other.interfaceName &&
          hopCount == other.hopCount;
}

class NetworkInterfaceHops {
  final List<NetworkInterfaceHop> hops;

  const NetworkInterfaceHops({required this.hops});

  @override
  int get hashCode => hops.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkInterfaceHops &&
          runtimeType == other.runtimeType &&
          hops == other.hops;
}
