// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `create_and_store_network_instance`, `create_config`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `RT`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `deref`, `initialize`

Future<(List<PeerInfo>, List<Route>)> getPeersAndRoutes() =>
    RustLib.instance.api.crateApiSimpleGetPeersAndRoutes();

Future<List<PeerRoutePair>> getPeerRoutePairs() =>
    RustLib.instance.api.crateApiSimpleGetPeerRoutePairs();

Future<MyNodeInfo> getNodeInfo() =>
    RustLib.instance.api.crateApiSimpleGetNodeInfo();

Future<String> easytierVersion() =>
    RustLib.instance.api.crateApiSimpleEasytierVersion();

Future<bool> isEasytierRunning() =>
    RustLib.instance.api.crateApiSimpleIsEasytierRunning();

Future<KVNetworkStatus> getNetworkStatus() =>
    RustLib.instance.api.crateApiSimpleGetNetworkStatus();

Future<String> getRunningInfo() =>
    RustLib.instance.api.crateApiSimpleGetRunningInfo();

Future<void> createServer(
        {required String username,
        required bool enableDhcp,
        required String specifiedIp,
        required String roomName,
        required String roomPassword,
        required String severurl}) =>
    RustLib.instance.api.crateApiSimpleCreateServer(
        username: username,
        enableDhcp: enableDhcp,
        specifiedIp: specifiedIp,
        roomName: roomName,
        roomPassword: roomPassword,
        severurl: severurl);

Future<void> closeAllServer() =>
    RustLib.instance.api.crateApiSimpleCloseAllServer();

Future<void> initApp() => RustLib.instance.api.crateApiSimpleInitApp();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MyNodeInfo>>
abstract class MyNodeInfo implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerInfo>>
abstract class PeerInfo implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerRoutePair>>
abstract class PeerRoutePair implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Route>>
abstract class Route implements RustOpaqueInterface {}

class KVNetworkStatus {
  final BigInt totalNodes;
  final List<KVNodeInfo> nodes;

  const KVNetworkStatus({
    required this.totalNodes,
    required this.nodes,
  });

  @override
  int get hashCode => totalNodes.hashCode ^ nodes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KVNetworkStatus &&
          runtimeType == other.runtimeType &&
          totalNodes == other.totalNodes &&
          nodes == other.nodes;
}

class KVNodeConnectionStats {
  final String connType;
  final BigInt rxBytes;
  final BigInt txBytes;
  final BigInt rxPackets;
  final BigInt txPackets;

  const KVNodeConnectionStats({
    required this.connType,
    required this.rxBytes,
    required this.txBytes,
    required this.rxPackets,
    required this.txPackets,
  });

  @override
  int get hashCode =>
      connType.hashCode ^
      rxBytes.hashCode ^
      txBytes.hashCode ^
      rxPackets.hashCode ^
      txPackets.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KVNodeConnectionStats &&
          runtimeType == other.runtimeType &&
          connType == other.connType &&
          rxBytes == other.rxBytes &&
          txBytes == other.txBytes &&
          rxPackets == other.rxPackets &&
          txPackets == other.txPackets;
}

class KVNodeInfo {
  final String hostname;
  final String ipv4;
  final double latencyMs;
  final String nat;
  final double lossRate;
  final List<KVNodeConnectionStats> connections;
  final String version;
  final int cost;

  const KVNodeInfo({
    required this.hostname,
    required this.ipv4,
    required this.latencyMs,
    required this.nat,
    required this.lossRate,
    required this.connections,
    required this.version,
    required this.cost,
  });

  @override
  int get hashCode =>
      hostname.hashCode ^
      ipv4.hashCode ^
      latencyMs.hashCode ^
      nat.hashCode ^
      lossRate.hashCode ^
      connections.hashCode ^
      version.hashCode ^
      cost.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KVNodeInfo &&
          runtimeType == other.runtimeType &&
          hostname == other.hostname &&
          ipv4 == other.ipv4 &&
          latencyMs == other.latencyMs &&
          nat == other.nat &&
          lossRate == other.lossRate &&
          connections == other.connections &&
          version == other.version &&
          cost == other.cost;
}
