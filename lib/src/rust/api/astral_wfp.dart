// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `add_advanced_network_filter`, `get_layers_for_rule`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_str`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `action`, `app_path`, `direction`, `local_ip_network_str`, `local_ip_network`, `local_ip_str`, `local_ip`, `local_port`, `protocol`, `remote_ip_network_str`, `remote_ip_network`, `remote_ip_str`, `remote_ip`, `remote_port`

Future<Uint16List> toWideString({required String s}) =>
    RustLib.instance.api.crateApiAstralWfpToWideString(s: s);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IpNetwork>>
abstract class IpNetwork implements RustOpaqueInterface {
  IpAddr get ip;

  int get prefixLen;

  set ip(IpAddr ip);

  set prefixLen(int prefixLen);

  Future<bool> contains({required IpAddr ip});

  static Future<IpNetwork> fromCidr({required String cidr}) =>
      RustLib.instance.api.crateApiAstralWfpIpNetworkFromCidr(cidr: cidr);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<IpNetwork> newInstance({
    required IpAddr ip,
    required int prefixLen,
  }) => RustLib.instance.api.crateApiAstralWfpIpNetworkNew(
    ip: ip,
    prefixLen: prefixLen,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WfpController>>
abstract class WfpController implements RustOpaqueInterface {
  Future<void> addAdvancedFilters({required List<FilterRule> rules});

  Future<void> cleanup();

  Future<void> initialize();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<WfpController> newInstance() =>
      RustLib.instance.api.crateApiAstralWfpWfpControllerNew();

  /// 打印当前WfpController实例的运行状态
  Future<void> printStatus();
}

enum Direction { inbound, outbound, both }

enum FilterAction { allow, block }

class FilterRule {
  final String name;
  final String? appPath;
  final String? localIp;
  final String? remoteIp;
  final String? localIpNetwork;
  final String? remoteIpNetwork;
  final int? localPort;
  final int? remotePort;
  final Protocol? protocol;
  final Direction direction;
  final FilterAction action;

  const FilterRule({
    required this.name,
    this.appPath,
    this.localIp,
    this.remoteIp,
    this.localIpNetwork,
    this.remoteIpNetwork,
    this.localPort,
    this.remotePort,
    this.protocol,
    required this.direction,
    required this.action,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FilterRule> newInstance({required String name}) =>
      RustLib.instance.api.crateApiAstralWfpFilterRuleNew(name: name);

  @override
  int get hashCode =>
      name.hashCode ^
      appPath.hashCode ^
      localIp.hashCode ^
      remoteIp.hashCode ^
      localIpNetwork.hashCode ^
      remoteIpNetwork.hashCode ^
      localPort.hashCode ^
      remotePort.hashCode ^
      protocol.hashCode ^
      direction.hashCode ^
      action.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FilterRule &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          appPath == other.appPath &&
          localIp == other.localIp &&
          remoteIp == other.remoteIp &&
          localIpNetwork == other.localIpNetwork &&
          remoteIpNetwork == other.remoteIpNetwork &&
          localPort == other.localPort &&
          remotePort == other.remotePort &&
          protocol == other.protocol &&
          direction == other.direction &&
          action == other.action;
}

enum Protocol { tcp, udp, icmp }
