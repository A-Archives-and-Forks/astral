// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `add_network_filter`, `validate_ip`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `action`, `app_path`, `direction`, `local_ip`, `local_port`, `protocol`, `remote_ip`, `remote_port`

Future<Uint16List> toWideString({required String s}) =>
    RustLib.instance.api.crateApiAstralWfpToWideString(s: s);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GUID>>
abstract class Guid implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IpNetwork>>
abstract class IpNetwork implements RustOpaqueInterface {
  IpAddr get ip;

  int get prefixLen;

  set ip(IpAddr ip);

  set prefixLen(int prefixLen);

  Future<bool> contains({required IpAddr ip});

  static Future<IpNetwork> fromCidr({required String cidr}) =>
      RustLib.instance.api.crateApiAstralWfpIpNetworkFromCidr(cidr: cidr);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<IpNetwork> newInstance({
    required IpAddr ip,
    required int prefixLen,
  }) => RustLib.instance.api.crateApiAstralWfpIpNetworkNew(
    ip: ip,
    prefixLen: prefixLen,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WfpController>>
abstract class WfpController implements RustOpaqueInterface {
  Future<void> addAdvancedFilters({required List<FilterRule> rules});

  Future<BigInt> addAdvancedNetworkFilter({
    required FilterRule rule,
    required Guid layerKey,
  });

  Uint64List get filterIds;

  set filterIds(Uint64List filterIds);

  Future<void> cleanup();

  Future<void> getLayerName({required Guid layerKey});

  Future<List<Guid>> getLayersForRule({required FilterRule rule});

  Future<void> initialize();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<WfpController> newInstance() =>
      RustLib.instance.api.crateApiAstralWfpWfpControllerNew();
}

enum Direction { inbound, outbound, both }

enum FilterAction { allow, block }

class FilterRule {
  final String name;
  final String? appPath;
  final String? local;
  final String? remote;
  final int? localPort;
  final int? remotePort;
  final Protocol? protocol;
  final Direction direction;
  final FilterAction action;

  const FilterRule({
    required this.name,
    this.appPath,
    this.local,
    this.remote,
    this.localPort,
    this.remotePort,
    this.protocol,
    required this.direction,
    required this.action,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FilterRule> newInstance({required String name}) =>
      RustLib.instance.api.crateApiAstralWfpFilterRuleNew(name: name);

  Future<void> validate() =>
      RustLib.instance.api.crateApiAstralWfpFilterRuleValidate(that: this);

  @override
  int get hashCode =>
      name.hashCode ^
      appPath.hashCode ^
      local.hashCode ^
      remote.hashCode ^
      localPort.hashCode ^
      remotePort.hashCode ^
      protocol.hashCode ^
      direction.hashCode ^
      action.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FilterRule &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          appPath == other.appPath &&
          local == other.local &&
          remote == other.remote &&
          localPort == other.localPort &&
          remotePort == other.remotePort &&
          protocol == other.protocol &&
          direction == other.direction &&
          action == other.action;
}

enum Protocol { tcp, udp, icmp }
