// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_str`

Future<Uint16List> toWideString({required String s}) =>
    RustLib.instance.api.crateApiAstralWfpToWideString(s: s);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IpNetwork>>
abstract class IpNetwork implements RustOpaqueInterface {
  IpAddr get ip;

  int get prefixLen;

  set ip(IpAddr ip);

  set prefixLen(int prefixLen);

  Future<bool> contains({required IpAddr ip});

  static Future<IpNetwork> fromCidr({required String cidr}) =>
      RustLib.instance.api.crateApiAstralWfpIpNetworkFromCidr(cidr: cidr);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<IpNetwork> newInstance({
    required IpAddr ip,
    required int prefixLen,
  }) => RustLib.instance.api.crateApiAstralWfpIpNetworkNew(
    ip: ip,
    prefixLen: prefixLen,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WfpController>>
abstract class WfpController implements RustOpaqueInterface {
  Future<void> addAdvancedFilters({required List<FilterRule> rules});

  Future<void> cleanup();

  Future<void> initialize();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<WfpController> newInstance() =>
      RustLib.instance.api.crateApiAstralWfpWfpControllerNew();

  Future<void> printStatus();
}

enum Direction { inbound, outbound, both }

enum FilterAction { allow, block }

class FilterRule {
  final String name;
  final String? appPath;
  final String? localIp;
  final String? remoteIp;
  final String? localIpNetwork;
  final String? remoteIpNetwork;
  final int? localPort;
  final int? remotePort;
  final Protocol? protocol;
  final Direction direction;
  final FilterAction action;

  const FilterRule({
    required this.name,
    this.appPath,
    this.localIp,
    this.remoteIp,
    this.localIpNetwork,
    this.remoteIpNetwork,
    this.localPort,
    this.remotePort,
    this.protocol,
    required this.direction,
    required this.action,
  });

  Future<FilterRule> action({required FilterAction action}) => RustLib
      .instance
      .api
      .crateApiAstralWfpFilterRuleAction(that: this, action: action);

  Future<FilterRule> appPath({required String path}) => RustLib.instance.api
      .crateApiAstralWfpFilterRuleAppPath(that: this, path: path);

  Future<FilterRule> direction({required Direction direction}) => RustLib
      .instance
      .api
      .crateApiAstralWfpFilterRuleDirection(that: this, direction: direction);

  Future<FilterRule> localIp({required IpAddr ip}) => RustLib.instance.api
      .crateApiAstralWfpFilterRuleLocalIp(that: this, ip: ip);

  Future<FilterRule> localIpNetwork({required IpNetwork network}) => RustLib
      .instance
      .api
      .crateApiAstralWfpFilterRuleLocalIpNetwork(that: this, network: network);

  Future<FilterRule> localIpNetworkStr({required String cidr}) => RustLib
      .instance
      .api
      .crateApiAstralWfpFilterRuleLocalIpNetworkStr(that: this, cidr: cidr);

  Future<FilterRule> localIpStr({required String ip}) => RustLib.instance.api
      .crateApiAstralWfpFilterRuleLocalIpStr(that: this, ip: ip);

  Future<FilterRule> localPort({required int port}) => RustLib.instance.api
      .crateApiAstralWfpFilterRuleLocalPort(that: this, port: port);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FilterRule> newInstance({required String name}) =>
      RustLib.instance.api.crateApiAstralWfpFilterRuleNew(name: name);

  Future<FilterRule> protocol({required Protocol protocol}) => RustLib
      .instance
      .api
      .crateApiAstralWfpFilterRuleProtocol(that: this, protocol: protocol);

  Future<FilterRule> remoteIp({required IpAddr ip}) => RustLib.instance.api
      .crateApiAstralWfpFilterRuleRemoteIp(that: this, ip: ip);

  Future<FilterRule> remoteIpNetwork({required IpNetwork network}) => RustLib
      .instance
      .api
      .crateApiAstralWfpFilterRuleRemoteIpNetwork(that: this, network: network);

  Future<FilterRule> remoteIpNetworkStr({required String cidr}) => RustLib
      .instance
      .api
      .crateApiAstralWfpFilterRuleRemoteIpNetworkStr(that: this, cidr: cidr);

  Future<FilterRule> remoteIpStr({required String ip}) => RustLib.instance.api
      .crateApiAstralWfpFilterRuleRemoteIpStr(that: this, ip: ip);

  Future<FilterRule> remotePort({required int port}) => RustLib.instance.api
      .crateApiAstralWfpFilterRuleRemotePort(that: this, port: port);

  @override
  int get hashCode =>
      name.hashCode ^
      appPath.hashCode ^
      localIp.hashCode ^
      remoteIp.hashCode ^
      localIpNetwork.hashCode ^
      remoteIpNetwork.hashCode ^
      localPort.hashCode ^
      remotePort.hashCode ^
      protocol.hashCode ^
      direction.hashCode ^
      action.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FilterRule &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          appPath == other.appPath &&
          localIp == other.localIp &&
          remoteIp == other.remoteIp &&
          localIpNetwork == other.localIpNetwork &&
          remoteIpNetwork == other.remoteIpNetwork &&
          localPort == other.localPort &&
          remotePort == other.remotePort &&
          protocol == other.protocol &&
          direction == other.direction &&
          action == other.action;
}

enum Protocol { tcp, udp, icmp }
