// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `validate_ip`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `FilterRuleConfig`, `RuleConfig`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_str`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `action`, `app_path`, `direction`, `local_ip`, `local_port_range`, `local_port`, `priority`, `protocol`, `remote_ip`, `remote_port_range`, `remote_port`

Future<Uint16List> toWideString({required String s}) =>
    RustLib.instance.api.crateApiAstralWfpToWideString(s: s);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FilterCache>>
abstract class FilterCache implements RustOpaqueInterface {
  Map<String, String> get appPathCache;

  Map<String, List<Guid>> get layerCache;

  set appPathCache(Map<String, String> appPathCache);

  set layerCache(Map<String, List<Guid>> layerCache);

  Future<String?> getNtPath({required String originalPath});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FilterCache> newInstance() =>
      RustLib.instance.api.crateApiAstralWfpFilterCacheNew();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FilterRule>>
abstract class FilterRule implements RustOpaqueInterface {
  FilterAction get action;

  String? get appPath;

  Direction get direction;

  String? get local;

  int? get localPort;

  (int, int)? get localPortRange;

  String get name;

  int get priority;

  Protocol? get protocol;

  String? get remote;

  int? get remotePort;

  (int, int)? get remotePortRange;

  set action(FilterAction action);

  set appPath(String? appPath);

  set direction(Direction direction);

  set local(String? local);

  set localPort(int? localPort);

  set localPortRange((int, int)? localPortRange);

  set name(String name);

  set priority(int priority);

  set protocol(Protocol? protocol);

  set remote(String? remote);

  set remotePort(int? remotePort);

  set remotePortRange((int, int)? remotePortRange);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FilterRule> newInstance({required String name}) =>
      RustLib.instance.api.crateApiAstralWfpFilterRuleNew(name: name);

  Future<String> signature();

  Future<void> validate();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GUID>>
abstract class Guid implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IpNetwork>>
abstract class IpNetwork implements RustOpaqueInterface {
  IpAddr get ip;

  int get prefixLen;

  set ip(IpAddr ip);

  set prefixLen(int prefixLen);

  Future<bool> contains({required IpAddr ip});

  static Future<IpNetwork> fromCidr({required String cidr}) =>
      RustLib.instance.api.crateApiAstralWfpIpNetworkFromCidr(cidr: cidr);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<IpNetwork> newInstance({
    required IpAddr ip,
    required int prefixLen,
  }) => RustLib.instance.api.crateApiAstralWfpIpNetworkNew(
    ip: ip,
    prefixLen: prefixLen,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Path>>
abstract class Path implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WfpController>>
abstract class WfpController implements RustOpaqueInterface {
  Future<Uint64List> addAdvancedFilters({required List<FilterRule> rules});

  Future<BigInt> addAdvancedNetworkFilter({
    required FilterRule rule,
    required Guid layerKey,
  });

  Uint64List get filterIds;

  set filterIds(Uint64List filterIds);

  Future<void> cleanup();

  Future<int> deleteFilters({required Uint64List filterIds});

  Future<void> exportRules({required Path filePath});

  Future<Uint64List> getFilterIds({required FilterRule rule});

  Future<void> getLayerName({required Guid layerKey});

  Future<List<Guid>> getLayersForRule({required FilterRule rule});

  Future<List<FilterRule>> getRules();

  Future<void> importRules({required Path filePath});

  Future<void> initialize();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<WfpController> newInstance() =>
      RustLib.instance.api.crateApiAstralWfpWfpControllerNew();

  Future<void> removeFilter({required BigInt filterId});
}

enum Direction { inbound, outbound, both }

enum FilterAction { allow, block }

enum Protocol { tcp, udp }
