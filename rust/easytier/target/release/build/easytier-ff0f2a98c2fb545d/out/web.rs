// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
    #[prost(string, optional, tag = "1")]
    #[serde(default)]
    pub instance_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    #[serde(default)]
    pub dhcp: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3")]
    #[serde(default)]
    pub virtual_ipv4: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    #[serde(default)]
    pub network_length: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    #[serde(default)]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    #[serde(default)]
    pub network_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    #[serde(default)]
    pub network_secret: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "NetworkingMethod", optional, tag = "8")]
    #[serde(default)]
    pub networking_method: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "9")]
    #[serde(default)]
    pub public_server_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "10")]
    #[serde(default)]
    pub peer_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "11")]
    #[serde(default)]
    pub proxy_cidrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "12")]
    #[serde(default)]
    pub enable_vpn_portal: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "13")]
    #[serde(default)]
    pub vpn_portal_listen_port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "14")]
    #[serde(default)]
    pub vpn_portal_client_network_addr: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(int32, optional, tag = "15")]
    #[serde(default)]
    pub vpn_portal_client_network_len: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "16")]
    #[serde(default)]
    pub advanced_settings: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "17")]
    #[serde(default)]
    pub listener_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "18")]
    #[serde(default)]
    pub rpc_port: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "19")]
    #[serde(default)]
    pub latency_first: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "20")]
    #[serde(default)]
    pub dev_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "21")]
    #[serde(default)]
    pub use_smoltcp: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "22")]
    #[serde(default)]
    pub enable_kcp_proxy: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "23")]
    #[serde(default)]
    pub disable_kcp_input: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "24")]
    #[serde(default)]
    pub disable_p2p: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "25")]
    #[serde(default)]
    pub bind_device: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "26")]
    #[serde(default)]
    pub no_tun: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "27")]
    #[serde(default)]
    pub enable_exit_node: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "28")]
    #[serde(default)]
    pub relay_all_peer_rpc: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "29")]
    #[serde(default)]
    pub multi_thread: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "30")]
    #[serde(default)]
    pub enable_relay_network_whitelist: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "31")]
    #[serde(default)]
    pub relay_network_whitelist: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, optional, tag = "32")]
    #[serde(default)]
    pub enable_manual_routes: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "33")]
    #[serde(default)]
    pub routes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "34")]
    #[serde(default)]
    pub exit_nodes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "35")]
    #[serde(default)]
    pub proxy_forward_by_system: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "36")]
    #[serde(default)]
    pub disable_encryption: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "37")]
    #[serde(default)]
    pub enable_socks5: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "38")]
    #[serde(default)]
    pub socks5_port: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MyNodeInfo {
    #[prost(message, optional, tag = "1")]
    pub virtual_ipv4: ::core::option::Option<super::common::Ipv4Inet>,
    #[prost(string, tag = "2")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub ips: ::core::option::Option<super::peer_rpc::GetIpListResponse>,
    #[prost(message, optional, tag = "5")]
    pub stun_info: ::core::option::Option<super::common::StunInfo>,
    #[prost(message, repeated, tag = "6")]
    pub listeners: ::prost::alloc::vec::Vec<super::common::Url>,
    #[prost(string, optional, tag = "7")]
    pub vpn_portal_cfg: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInstanceRunningInfo {
    #[prost(string, tag = "1")]
    pub dev_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub my_node_info: ::core::option::Option<MyNodeInfo>,
    #[prost(string, repeated, tag = "3")]
    pub events: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub routes: ::prost::alloc::vec::Vec<super::cli::Route>,
    #[prost(message, repeated, tag = "5")]
    pub peers: ::prost::alloc::vec::Vec<super::cli::PeerInfo>,
    #[prost(message, repeated, tag = "6")]
    pub peer_route_pairs: ::prost::alloc::vec::Vec<super::cli::PeerRoutePair>,
    #[prost(bool, tag = "7")]
    pub running: bool,
    #[prost(string, optional, tag = "8")]
    pub error_msg: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInstanceRunningInfoMap {
    #[prost(btree_map = "string, message", tag = "1")]
    pub map: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        NetworkInstanceRunningInfo,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatRequest {
    #[prost(message, optional, tag = "1")]
    pub machine_id: ::core::option::Option<super::common::Uuid>,
    #[prost(message, optional, tag = "2")]
    pub inst_id: ::core::option::Option<super::common::Uuid>,
    #[prost(string, tag = "3")]
    pub user_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub easytier_version: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub report_time: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub running_network_instances: ::prost::alloc::vec::Vec<super::common::Uuid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HeartbeatResponse {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<NetworkConfig>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateConfigResponse {
    #[prost(string, tag = "1")]
    pub toml_config: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunNetworkInstanceRequest {
    #[prost(message, optional, tag = "1")]
    pub inst_id: ::core::option::Option<super::common::Uuid>,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<NetworkConfig>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RunNetworkInstanceResponse {
    #[prost(message, optional, tag = "1")]
    pub inst_id: ::core::option::Option<super::common::Uuid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetainNetworkInstanceRequest {
    #[prost(message, repeated, tag = "1")]
    pub inst_ids: ::prost::alloc::vec::Vec<super::common::Uuid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetainNetworkInstanceResponse {
    #[prost(message, repeated, tag = "1")]
    pub remain_inst_ids: ::prost::alloc::vec::Vec<super::common::Uuid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectNetworkInfoRequest {
    #[prost(message, repeated, tag = "1")]
    pub inst_ids: ::prost::alloc::vec::Vec<super::common::Uuid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectNetworkInfoResponse {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<NetworkInstanceRunningInfoMap>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListNetworkInstanceRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkInstanceResponse {
    #[prost(message, repeated, tag = "1")]
    pub inst_ids: ::prost::alloc::vec::Vec<super::common::Uuid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetworkInstanceRequest {
    #[prost(message, repeated, tag = "1")]
    pub inst_ids: ::prost::alloc::vec::Vec<super::common::Uuid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetworkInstanceResponse {
    #[prost(message, repeated, tag = "1")]
    pub remain_inst_ids: ::prost::alloc::vec::Vec<super::common::Uuid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetworkingMethod {
    PublicServer = 0,
    Manual = 1,
    Standalone = 2,
}
impl NetworkingMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PublicServer => "PublicServer",
            Self::Manual => "Manual",
            Self::Standalone => "Standalone",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PublicServer" => Some(Self::PublicServer),
            "Manual" => Some(Self::Manual),
            "Standalone" => Some(Self::Standalone),
            _ => None,
        }
    }
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait WebServerService {
    type Controller: crate::proto::rpc_types::controller::Controller;
    async fn heartbeat(
        &self,
        ctrl: Self::Controller,
        input: HeartbeatRequest,
    ) -> crate::proto::rpc_types::error::Result<HeartbeatResponse>;
}
/// A service descriptor for a `WebServerService`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct WebServerServiceDescriptor;
/// Methods available on a `WebServerService`.
///
/// This can be used as a key when routing requests for servers/clients of a `WebServerService`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum WebServerServiceMethodDescriptor {
    Heartbeat = 1,
}
impl std::convert::TryFrom<u8> for WebServerServiceMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(WebServerServiceMethodDescriptor::Heartbeat),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "WebServerService".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `WebServerService`.
///
/// This implements the `WebServerService` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct WebServerServiceClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> WebServerServiceClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = WebServerServiceDescriptor,
    >,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> WebServerServiceClient<H> {
        WebServerServiceClient(handler)
    }
}
impl<H> WebServerServiceClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = WebServerServiceDescriptor,
    >,
{
    async fn heartbeat_inner(
        handler: H,
        ctrl: H::Controller,
        input: HeartbeatRequest,
    ) -> crate::proto::rpc_types::error::Result<HeartbeatResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                WebServerServiceMethodDescriptor::Heartbeat,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> WebServerService for WebServerServiceClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = WebServerServiceDescriptor,
    >,
{
    type Controller = H::Controller;
    async fn heartbeat(
        &self,
        ctrl: H::Controller,
        input: HeartbeatRequest,
    ) -> crate::proto::rpc_types::error::Result<HeartbeatResponse> {
        WebServerServiceClient::heartbeat_inner(self.0.clone(), ctrl, input).await
    }
}
pub struct WebServerServiceClientFactory<
    C: crate::proto::rpc_types::controller::Controller,
>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for WebServerServiceClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory
for WebServerServiceClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = WebServerServiceDescriptor;
    type ClientImpl = Box<dyn WebServerService<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(WebServerServiceClient::new(handler))
    }
}
/// A server for a `WebServerService`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `WebServerService`.
#[derive(Clone, Debug)]
pub struct WebServerServiceServer<A>(
    A,
)
where
    A: WebServerService + Clone + Send + 'static;
impl<A> WebServerServiceServer<A>
where
    A: WebServerService + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> WebServerServiceServer<A> {
        WebServerServiceServer(service)
    }
    async fn call_inner(
        service: A,
        method: WebServerServiceMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            WebServerServiceMethodDescriptor::Heartbeat => {
                let decoded: HeartbeatRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.heartbeat(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor
for WebServerServiceDescriptor {
    type Method = WebServerServiceMethodDescriptor;
    fn name(&self) -> &'static str {
        "WebServerService"
    }
    fn proto_name(&self) -> &'static str {
        "WebServerService"
    }
    fn package(&self) -> &'static str {
        "web"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[WebServerServiceMethodDescriptor::Heartbeat]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for WebServerServiceServer<A>
where
    A: WebServerService + Clone + Send + Sync + 'static,
{
    type Descriptor = WebServerServiceDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: WebServerServiceMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        WebServerServiceServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor
for WebServerServiceMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            WebServerServiceMethodDescriptor::Heartbeat => "heartbeat",
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            WebServerServiceMethodDescriptor::Heartbeat => "Heartbeat",
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            WebServerServiceMethodDescriptor::Heartbeat => {
                ::std::any::TypeId::of::<HeartbeatRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            WebServerServiceMethodDescriptor::Heartbeat => ".web.HeartbeatRequest",
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            WebServerServiceMethodDescriptor::Heartbeat => {
                ::std::any::TypeId::of::<HeartbeatResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            WebServerServiceMethodDescriptor::Heartbeat => ".web.HeartbeatResponse",
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait WebClientService {
    type Controller: crate::proto::rpc_types::controller::Controller;
    async fn validate_config(
        &self,
        ctrl: Self::Controller,
        input: ValidateConfigRequest,
    ) -> crate::proto::rpc_types::error::Result<ValidateConfigResponse>;
    async fn run_network_instance(
        &self,
        ctrl: Self::Controller,
        input: RunNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<RunNetworkInstanceResponse>;
    async fn retain_network_instance(
        &self,
        ctrl: Self::Controller,
        input: RetainNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<RetainNetworkInstanceResponse>;
    async fn collect_network_info(
        &self,
        ctrl: Self::Controller,
        input: CollectNetworkInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<CollectNetworkInfoResponse>;
    async fn list_network_instance(
        &self,
        ctrl: Self::Controller,
        input: ListNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<ListNetworkInstanceResponse>;
    async fn delete_network_instance(
        &self,
        ctrl: Self::Controller,
        input: DeleteNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<DeleteNetworkInstanceResponse>;
}
/// A service descriptor for a `WebClientService`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct WebClientServiceDescriptor;
/// Methods available on a `WebClientService`.
///
/// This can be used as a key when routing requests for servers/clients of a `WebClientService`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum WebClientServiceMethodDescriptor {
    ValidateConfig = 1,
    RunNetworkInstance = 2,
    RetainNetworkInstance = 3,
    CollectNetworkInfo = 4,
    ListNetworkInstance = 5,
    DeleteNetworkInstance = 6,
}
impl std::convert::TryFrom<u8> for WebClientServiceMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(WebClientServiceMethodDescriptor::ValidateConfig),
            2 => Ok(WebClientServiceMethodDescriptor::RunNetworkInstance),
            3 => Ok(WebClientServiceMethodDescriptor::RetainNetworkInstance),
            4 => Ok(WebClientServiceMethodDescriptor::CollectNetworkInfo),
            5 => Ok(WebClientServiceMethodDescriptor::ListNetworkInstance),
            6 => Ok(WebClientServiceMethodDescriptor::DeleteNetworkInstance),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "WebClientService".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `WebClientService`.
///
/// This implements the `WebClientService` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct WebClientServiceClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> WebClientServiceClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = WebClientServiceDescriptor,
    >,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> WebClientServiceClient<H> {
        WebClientServiceClient(handler)
    }
}
impl<H> WebClientServiceClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = WebClientServiceDescriptor,
    >,
{
    async fn validate_config_inner(
        handler: H,
        ctrl: H::Controller,
        input: ValidateConfigRequest,
    ) -> crate::proto::rpc_types::error::Result<ValidateConfigResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                WebClientServiceMethodDescriptor::ValidateConfig,
                input,
            )
            .await
    }
    async fn run_network_instance_inner(
        handler: H,
        ctrl: H::Controller,
        input: RunNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<RunNetworkInstanceResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                WebClientServiceMethodDescriptor::RunNetworkInstance,
                input,
            )
            .await
    }
    async fn retain_network_instance_inner(
        handler: H,
        ctrl: H::Controller,
        input: RetainNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<RetainNetworkInstanceResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                WebClientServiceMethodDescriptor::RetainNetworkInstance,
                input,
            )
            .await
    }
    async fn collect_network_info_inner(
        handler: H,
        ctrl: H::Controller,
        input: CollectNetworkInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<CollectNetworkInfoResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                WebClientServiceMethodDescriptor::CollectNetworkInfo,
                input,
            )
            .await
    }
    async fn list_network_instance_inner(
        handler: H,
        ctrl: H::Controller,
        input: ListNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<ListNetworkInstanceResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                WebClientServiceMethodDescriptor::ListNetworkInstance,
                input,
            )
            .await
    }
    async fn delete_network_instance_inner(
        handler: H,
        ctrl: H::Controller,
        input: DeleteNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<DeleteNetworkInstanceResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                WebClientServiceMethodDescriptor::DeleteNetworkInstance,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> WebClientService for WebClientServiceClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = WebClientServiceDescriptor,
    >,
{
    type Controller = H::Controller;
    async fn validate_config(
        &self,
        ctrl: H::Controller,
        input: ValidateConfigRequest,
    ) -> crate::proto::rpc_types::error::Result<ValidateConfigResponse> {
        WebClientServiceClient::validate_config_inner(self.0.clone(), ctrl, input).await
    }
    async fn run_network_instance(
        &self,
        ctrl: H::Controller,
        input: RunNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<RunNetworkInstanceResponse> {
        WebClientServiceClient::run_network_instance_inner(self.0.clone(), ctrl, input)
            .await
    }
    async fn retain_network_instance(
        &self,
        ctrl: H::Controller,
        input: RetainNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<RetainNetworkInstanceResponse> {
        WebClientServiceClient::retain_network_instance_inner(
                self.0.clone(),
                ctrl,
                input,
            )
            .await
    }
    async fn collect_network_info(
        &self,
        ctrl: H::Controller,
        input: CollectNetworkInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<CollectNetworkInfoResponse> {
        WebClientServiceClient::collect_network_info_inner(self.0.clone(), ctrl, input)
            .await
    }
    async fn list_network_instance(
        &self,
        ctrl: H::Controller,
        input: ListNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<ListNetworkInstanceResponse> {
        WebClientServiceClient::list_network_instance_inner(self.0.clone(), ctrl, input)
            .await
    }
    async fn delete_network_instance(
        &self,
        ctrl: H::Controller,
        input: DeleteNetworkInstanceRequest,
    ) -> crate::proto::rpc_types::error::Result<DeleteNetworkInstanceResponse> {
        WebClientServiceClient::delete_network_instance_inner(
                self.0.clone(),
                ctrl,
                input,
            )
            .await
    }
}
pub struct WebClientServiceClientFactory<
    C: crate::proto::rpc_types::controller::Controller,
>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for WebClientServiceClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory
for WebClientServiceClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = WebClientServiceDescriptor;
    type ClientImpl = Box<dyn WebClientService<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(WebClientServiceClient::new(handler))
    }
}
/// A server for a `WebClientService`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `WebClientService`.
#[derive(Clone, Debug)]
pub struct WebClientServiceServer<A>(
    A,
)
where
    A: WebClientService + Clone + Send + 'static;
impl<A> WebClientServiceServer<A>
where
    A: WebClientService + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> WebClientServiceServer<A> {
        WebClientServiceServer(service)
    }
    async fn call_inner(
        service: A,
        method: WebClientServiceMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            WebClientServiceMethodDescriptor::ValidateConfig => {
                let decoded: ValidateConfigRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.validate_config(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            WebClientServiceMethodDescriptor::RunNetworkInstance => {
                let decoded: RunNetworkInstanceRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.run_network_instance(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            WebClientServiceMethodDescriptor::RetainNetworkInstance => {
                let decoded: RetainNetworkInstanceRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.retain_network_instance(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            WebClientServiceMethodDescriptor::CollectNetworkInfo => {
                let decoded: CollectNetworkInfoRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.collect_network_info(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            WebClientServiceMethodDescriptor::ListNetworkInstance => {
                let decoded: ListNetworkInstanceRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.list_network_instance(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            WebClientServiceMethodDescriptor::DeleteNetworkInstance => {
                let decoded: DeleteNetworkInstanceRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.delete_network_instance(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor
for WebClientServiceDescriptor {
    type Method = WebClientServiceMethodDescriptor;
    fn name(&self) -> &'static str {
        "WebClientService"
    }
    fn proto_name(&self) -> &'static str {
        "WebClientService"
    }
    fn package(&self) -> &'static str {
        "web"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[
            WebClientServiceMethodDescriptor::ValidateConfig,
            WebClientServiceMethodDescriptor::RunNetworkInstance,
            WebClientServiceMethodDescriptor::RetainNetworkInstance,
            WebClientServiceMethodDescriptor::CollectNetworkInfo,
            WebClientServiceMethodDescriptor::ListNetworkInstance,
            WebClientServiceMethodDescriptor::DeleteNetworkInstance,
        ]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for WebClientServiceServer<A>
where
    A: WebClientService + Clone + Send + Sync + 'static,
{
    type Descriptor = WebClientServiceDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: WebClientServiceMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        WebClientServiceServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor
for WebClientServiceMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            WebClientServiceMethodDescriptor::ValidateConfig => "validate_config",
            WebClientServiceMethodDescriptor::RunNetworkInstance => {
                "run_network_instance"
            }
            WebClientServiceMethodDescriptor::RetainNetworkInstance => {
                "retain_network_instance"
            }
            WebClientServiceMethodDescriptor::CollectNetworkInfo => {
                "collect_network_info"
            }
            WebClientServiceMethodDescriptor::ListNetworkInstance => {
                "list_network_instance"
            }
            WebClientServiceMethodDescriptor::DeleteNetworkInstance => {
                "delete_network_instance"
            }
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            WebClientServiceMethodDescriptor::ValidateConfig => "ValidateConfig",
            WebClientServiceMethodDescriptor::RunNetworkInstance => "RunNetworkInstance",
            WebClientServiceMethodDescriptor::RetainNetworkInstance => {
                "RetainNetworkInstance"
            }
            WebClientServiceMethodDescriptor::CollectNetworkInfo => "CollectNetworkInfo",
            WebClientServiceMethodDescriptor::ListNetworkInstance => {
                "ListNetworkInstance"
            }
            WebClientServiceMethodDescriptor::DeleteNetworkInstance => {
                "DeleteNetworkInstance"
            }
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            WebClientServiceMethodDescriptor::ValidateConfig => {
                ::std::any::TypeId::of::<ValidateConfigRequest>()
            }
            WebClientServiceMethodDescriptor::RunNetworkInstance => {
                ::std::any::TypeId::of::<RunNetworkInstanceRequest>()
            }
            WebClientServiceMethodDescriptor::RetainNetworkInstance => {
                ::std::any::TypeId::of::<RetainNetworkInstanceRequest>()
            }
            WebClientServiceMethodDescriptor::CollectNetworkInfo => {
                ::std::any::TypeId::of::<CollectNetworkInfoRequest>()
            }
            WebClientServiceMethodDescriptor::ListNetworkInstance => {
                ::std::any::TypeId::of::<ListNetworkInstanceRequest>()
            }
            WebClientServiceMethodDescriptor::DeleteNetworkInstance => {
                ::std::any::TypeId::of::<DeleteNetworkInstanceRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            WebClientServiceMethodDescriptor::ValidateConfig => {
                ".web.ValidateConfigRequest"
            }
            WebClientServiceMethodDescriptor::RunNetworkInstance => {
                ".web.RunNetworkInstanceRequest"
            }
            WebClientServiceMethodDescriptor::RetainNetworkInstance => {
                ".web.RetainNetworkInstanceRequest"
            }
            WebClientServiceMethodDescriptor::CollectNetworkInfo => {
                ".web.CollectNetworkInfoRequest"
            }
            WebClientServiceMethodDescriptor::ListNetworkInstance => {
                ".web.ListNetworkInstanceRequest"
            }
            WebClientServiceMethodDescriptor::DeleteNetworkInstance => {
                ".web.DeleteNetworkInstanceRequest"
            }
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            WebClientServiceMethodDescriptor::ValidateConfig => {
                ::std::any::TypeId::of::<ValidateConfigResponse>()
            }
            WebClientServiceMethodDescriptor::RunNetworkInstance => {
                ::std::any::TypeId::of::<RunNetworkInstanceResponse>()
            }
            WebClientServiceMethodDescriptor::RetainNetworkInstance => {
                ::std::any::TypeId::of::<RetainNetworkInstanceResponse>()
            }
            WebClientServiceMethodDescriptor::CollectNetworkInfo => {
                ::std::any::TypeId::of::<CollectNetworkInfoResponse>()
            }
            WebClientServiceMethodDescriptor::ListNetworkInstance => {
                ::std::any::TypeId::of::<ListNetworkInstanceResponse>()
            }
            WebClientServiceMethodDescriptor::DeleteNetworkInstance => {
                ::std::any::TypeId::of::<DeleteNetworkInstanceResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            WebClientServiceMethodDescriptor::ValidateConfig => {
                ".web.ValidateConfigResponse"
            }
            WebClientServiceMethodDescriptor::RunNetworkInstance => {
                ".web.RunNetworkInstanceResponse"
            }
            WebClientServiceMethodDescriptor::RetainNetworkInstance => {
                ".web.RetainNetworkInstanceResponse"
            }
            WebClientServiceMethodDescriptor::CollectNetworkInfo => {
                ".web.CollectNetworkInfoResponse"
            }
            WebClientServiceMethodDescriptor::ListNetworkInstance => {
                ".web.ListNetworkInstanceResponse"
            }
            WebClientServiceMethodDescriptor::DeleteNetworkInstance => {
                ".web.DeleteNetworkInstanceResponse"
            }
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
