// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.FlagsInConfig")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlagsInConfig {
    #[prost(string, tag = "1")]
    pub default_protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub dev_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub enable_encryption: bool,
    #[prost(bool, tag = "4")]
    pub enable_ipv6: bool,
    #[prost(uint32, tag = "5")]
    pub mtu: u32,
    #[prost(bool, tag = "6")]
    pub latency_first: bool,
    #[prost(bool, tag = "7")]
    pub enable_exit_node: bool,
    #[prost(bool, tag = "8")]
    pub no_tun: bool,
    #[prost(bool, tag = "9")]
    pub use_smoltcp: bool,
    #[prost(string, tag = "10")]
    pub relay_network_whitelist: ::prost::alloc::string::String,
    #[prost(bool, tag = "11")]
    pub disable_p2p: bool,
    #[prost(bool, tag = "12")]
    pub relay_all_peer_rpc: bool,
    #[prost(bool, tag = "13")]
    pub disable_udp_hole_punching: bool,
    /// string ipv6_listener = 14; \[deprecated = true\]; use -l udp://\[::\]:12345 instead
    #[prost(bool, tag = "15")]
    pub multi_thread: bool,
    #[prost(enumeration = "CompressionAlgoPb", tag = "16")]
    pub data_compress_algo: i32,
    #[prost(bool, tag = "17")]
    pub bind_device: bool,
    /// should we convert all tcp streams into kcp streams
    #[prost(bool, tag = "18")]
    pub enable_kcp_proxy: bool,
    /// does this peer allow kcp input
    #[prost(bool, tag = "19")]
    pub disable_kcp_input: bool,
    /// allow relay kcp packets (for public server, this can reduce the throughput)
    #[prost(bool, tag = "20")]
    pub disable_relay_kcp: bool,
    #[prost(bool, tag = "21")]
    pub proxy_forward_by_system: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Hash, Eq)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.RpcDescriptor")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcDescriptor {
    /// allow same service registered multiple times in different domain
    #[prost(string, tag = "1")]
    pub domain_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub proto_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub service_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub method_index: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.RpcRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcRequest {
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub descriptor: ::core::option::Option<RpcDescriptor>,
    #[prost(bytes = "vec", tag = "2")]
    pub request: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, tag = "3")]
    pub timeout_ms: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.RpcResponse")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub response: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<super::error::Error>,
    #[prost(uint64, tag = "3")]
    pub runtime_us: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.RpcCompressionInfo")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RpcCompressionInfo {
    /// use this to compress the content
    #[prost(enumeration = "CompressionAlgoPb", tag = "1")]
    pub algo: i32,
    /// tell the peer which compression algo is used to compress the next
    /// response/request
    #[prost(enumeration = "CompressionAlgoPb", tag = "2")]
    pub accepted_algo: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.RpcPacket")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcPacket {
    #[prost(uint32, tag = "1")]
    pub from_peer: u32,
    #[prost(uint32, tag = "2")]
    pub to_peer: u32,
    #[prost(int64, tag = "3")]
    pub transaction_id: i64,
    #[prost(message, optional, tag = "4")]
    pub descriptor: ::core::option::Option<RpcDescriptor>,
    #[prost(bytes = "vec", tag = "5")]
    pub body: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "6")]
    pub is_request: bool,
    #[prost(uint32, tag = "7")]
    pub total_pieces: u32,
    #[prost(uint32, tag = "8")]
    pub piece_idx: u32,
    #[prost(int32, tag = "9")]
    pub trace_id: i32,
    #[prost(message, optional, tag = "10")]
    pub compression_info: ::core::option::Option<RpcCompressionInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.Void")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Void {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.UUID")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Uuid {
    #[prost(uint32, tag = "1")]
    pub part1: u32,
    #[prost(uint32, tag = "2")]
    pub part2: u32,
    #[prost(uint32, tag = "3")]
    pub part3: u32,
    #[prost(uint32, tag = "4")]
    pub part4: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.Ipv4Addr")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ipv4Addr {
    #[prost(uint32, tag = "1")]
    pub addr: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.Ipv6Addr")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ipv6Addr {
    #[prost(uint32, tag = "1")]
    pub part1: u32,
    #[prost(uint32, tag = "2")]
    pub part2: u32,
    #[prost(uint32, tag = "3")]
    pub part3: u32,
    #[prost(uint32, tag = "4")]
    pub part4: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.Ipv4Inet")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ipv4Inet {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<Ipv4Addr>,
    #[prost(uint32, tag = "2")]
    pub network_length: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.Url")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Url {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.SocketAddr")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SocketAddr {
    #[prost(uint32, tag = "3")]
    pub port: u32,
    #[prost(oneof = "socket_addr::Ip", tags = "1, 2")]
    pub ip: ::core::option::Option<socket_addr::Ip>,
}
/// Nested message and enum types in `SocketAddr`.
pub mod socket_addr {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Ip {
        #[prost(message, tag = "1")]
        Ipv4(super::Ipv4Addr),
        #[prost(message, tag = "2")]
        Ipv6(super::Ipv6Addr),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.TunnelInfo")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TunnelInfo {
    #[prost(string, tag = "1")]
    pub tunnel_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub local_addr: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "3")]
    pub remote_addr: ::core::option::Option<Url>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.StunInfo")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StunInfo {
    #[prost(enumeration = "NatType", tag = "1")]
    pub udp_nat_type: i32,
    #[prost(enumeration = "NatType", tag = "2")]
    pub tcp_nat_type: i32,
    #[prost(int64, tag = "3")]
    pub last_update_time: i64,
    #[prost(string, repeated, tag = "4")]
    pub public_ip: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "5")]
    pub min_port: u32,
    #[prost(uint32, tag = "6")]
    pub max_port: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "common.PeerFeatureFlag")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PeerFeatureFlag {
    #[prost(bool, tag = "1")]
    pub is_public_server: bool,
    #[prost(bool, tag = "2")]
    pub avoid_relay_data: bool,
    #[prost(bool, tag = "3")]
    pub kcp_input: bool,
    #[prost(bool, tag = "4")]
    pub no_relay_kcp: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressionAlgoPb {
    Invalid = 0,
    None = 1,
    Zstd = 2,
}
impl CompressionAlgoPb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "Invalid",
            Self::None => "None",
            Self::Zstd => "Zstd",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Invalid" => Some(Self::Invalid),
            "None" => Some(Self::None),
            "Zstd" => Some(Self::Zstd),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NatType {
    /// has NAT; but own a single public IP, port is not changed
    Unknown = 0,
    OpenInternet = 1,
    NoPat = 2,
    FullCone = 3,
    Restricted = 4,
    PortRestricted = 5,
    Symmetric = 6,
    SymUdpFirewall = 7,
    SymmetricEasyInc = 8,
    SymmetricEasyDec = 9,
}
impl NatType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::OpenInternet => "OpenInternet",
            Self::NoPat => "NoPAT",
            Self::FullCone => "FullCone",
            Self::Restricted => "Restricted",
            Self::PortRestricted => "PortRestricted",
            Self::Symmetric => "Symmetric",
            Self::SymUdpFirewall => "SymUdpFirewall",
            Self::SymmetricEasyInc => "SymmetricEasyInc",
            Self::SymmetricEasyDec => "SymmetricEasyDec",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "OpenInternet" => Some(Self::OpenInternet),
            "NoPAT" => Some(Self::NoPat),
            "FullCone" => Some(Self::FullCone),
            "Restricted" => Some(Self::Restricted),
            "PortRestricted" => Some(Self::PortRestricted),
            "Symmetric" => Some(Self::Symmetric),
            "SymUdpFirewall" => Some(Self::SymUdpFirewall),
            "SymmetricEasyInc" => Some(Self::SymmetricEasyInc),
            "SymmetricEasyDec" => Some(Self::SymmetricEasyDec),
            _ => None,
        }
    }
}
