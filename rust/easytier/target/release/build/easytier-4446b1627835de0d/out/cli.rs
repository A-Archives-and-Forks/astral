// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Status {
    #[prost(int32, tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PeerConnStats {
    #[prost(uint64, tag = "1")]
    pub rx_bytes: u64,
    #[prost(uint64, tag = "2")]
    pub tx_bytes: u64,
    #[prost(uint64, tag = "3")]
    pub rx_packets: u64,
    #[prost(uint64, tag = "4")]
    pub tx_packets: u64,
    #[prost(uint64, tag = "5")]
    pub latency_us: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerConnInfo {
    #[prost(string, tag = "1")]
    pub conn_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub my_peer_id: u32,
    #[prost(uint32, tag = "3")]
    pub peer_id: u32,
    #[prost(string, repeated, tag = "4")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub tunnel: ::core::option::Option<super::common::TunnelInfo>,
    #[prost(message, optional, tag = "6")]
    pub stats: ::core::option::Option<PeerConnStats>,
    #[prost(float, tag = "7")]
    pub loss_rate: f32,
    #[prost(bool, tag = "8")]
    pub is_client: bool,
    #[prost(string, tag = "9")]
    pub network_name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerInfo {
    #[prost(uint32, tag = "1")]
    pub peer_id: u32,
    #[prost(message, repeated, tag = "2")]
    pub conns: ::prost::alloc::vec::Vec<PeerConnInfo>,
    #[prost(message, optional, tag = "3")]
    pub default_conn_id: ::core::option::Option<super::common::Uuid>,
    #[prost(message, repeated, tag = "4")]
    pub directly_connected_conns: ::prost::alloc::vec::Vec<super::common::Uuid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListPeerRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPeerResponse {
    #[prost(message, repeated, tag = "1")]
    pub peer_infos: ::prost::alloc::vec::Vec<PeerInfo>,
    #[prost(message, optional, tag = "2")]
    pub my_info: ::core::option::Option<NodeInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Route {
    #[prost(uint32, tag = "1")]
    pub peer_id: u32,
    #[prost(message, optional, tag = "2")]
    pub ipv4_addr: ::core::option::Option<super::common::Ipv4Inet>,
    #[prost(uint32, tag = "3")]
    pub next_hop_peer_id: u32,
    #[prost(int32, tag = "4")]
    pub cost: i32,
    #[prost(int32, tag = "11")]
    pub path_latency: i32,
    #[prost(string, repeated, tag = "5")]
    pub proxy_cidrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub stun_info: ::core::option::Option<super::common::StunInfo>,
    #[prost(string, tag = "8")]
    pub inst_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub feature_flag: ::core::option::Option<super::common::PeerFeatureFlag>,
    #[prost(uint32, optional, tag = "12")]
    pub next_hop_peer_id_latency_first: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "13")]
    pub cost_latency_first: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "14")]
    pub path_latency_latency_first: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerRoutePair {
    #[prost(message, optional, tag = "1")]
    pub route: ::core::option::Option<Route>,
    #[prost(message, optional, tag = "2")]
    pub peer: ::core::option::Option<PeerInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeInfo {
    #[prost(uint32, tag = "1")]
    pub peer_id: u32,
    #[prost(string, tag = "2")]
    pub ipv4_addr: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub proxy_cidrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub stun_info: ::core::option::Option<super::common::StunInfo>,
    #[prost(string, tag = "6")]
    pub inst_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub listeners: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "8")]
    pub config: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub feature_flag: ::core::option::Option<super::common::PeerFeatureFlag>,
    #[prost(message, optional, tag = "11")]
    pub ip_list: ::core::option::Option<super::peer_rpc::GetIpListResponse>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShowNodeInfoRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowNodeInfoResponse {
    #[prost(message, optional, tag = "1")]
    pub node_info: ::core::option::Option<NodeInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListRouteRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRouteResponse {
    #[prost(message, repeated, tag = "1")]
    pub routes: ::prost::alloc::vec::Vec<Route>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DumpRouteRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DumpRouteResponse {
    #[prost(string, tag = "1")]
    pub result: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListForeignNetworkRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForeignNetworkEntryPb {
    #[prost(message, repeated, tag = "1")]
    pub peers: ::prost::alloc::vec::Vec<PeerInfo>,
    #[prost(bytes = "vec", tag = "2")]
    pub network_secret_digest: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListForeignNetworkResponse {
    /// foreign network in local
    #[prost(btree_map = "string, message", tag = "1")]
    pub foreign_networks: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ForeignNetworkEntryPb,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListGlobalForeignNetworkRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGlobalForeignNetworkResponse {
    #[prost(btree_map = "uint32, message", tag = "1")]
    pub foreign_networks: ::prost::alloc::collections::BTreeMap<
        u32,
        list_global_foreign_network_response::ForeignNetworks,
    >,
}
/// Nested message and enum types in `ListGlobalForeignNetworkResponse`.
pub mod list_global_foreign_network_response {
    /// foreign network in the entire network
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OneForeignNetwork {
        #[prost(string, tag = "1")]
        pub network_name: ::prost::alloc::string::String,
        #[prost(uint32, repeated, tag = "2")]
        pub peer_ids: ::prost::alloc::vec::Vec<u32>,
        #[prost(string, tag = "3")]
        pub last_updated: ::prost::alloc::string::String,
        #[prost(uint32, tag = "4")]
        pub version: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ForeignNetworks {
        #[prost(message, repeated, tag = "1")]
        pub foreign_networks: ::prost::alloc::vec::Vec<OneForeignNetwork>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Connector {
    #[prost(message, optional, tag = "1")]
    pub url: ::core::option::Option<super::common::Url>,
    #[prost(enumeration = "ConnectorStatus", tag = "2")]
    pub status: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListConnectorRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectorResponse {
    #[prost(message, repeated, tag = "1")]
    pub connectors: ::prost::alloc::vec::Vec<Connector>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManageConnectorRequest {
    #[prost(enumeration = "ConnectorManageAction", tag = "1")]
    pub action: i32,
    #[prost(message, optional, tag = "2")]
    pub url: ::core::option::Option<super::common::Url>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManageConnectorResponse {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnPortalInfo {
    #[prost(string, tag = "1")]
    pub vpn_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub client_config: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub connected_clients: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetVpnPortalInfoRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVpnPortalInfoResponse {
    #[prost(message, optional, tag = "1")]
    pub vpn_portal_info: ::core::option::Option<VpnPortalInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TcpProxyEntry {
    #[prost(message, optional, tag = "1")]
    pub src: ::core::option::Option<super::common::SocketAddr>,
    #[prost(message, optional, tag = "2")]
    pub dst: ::core::option::Option<super::common::SocketAddr>,
    #[prost(uint64, tag = "3")]
    pub start_time: u64,
    #[prost(enumeration = "TcpProxyEntryState", tag = "4")]
    pub state: i32,
    #[prost(enumeration = "TcpProxyEntryTransportType", tag = "5")]
    pub transport_type: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListTcpProxyEntryRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTcpProxyEntryResponse {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<TcpProxyEntry>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConnectorStatus {
    Connected = 0,
    Disconnected = 1,
    Connecting = 2,
}
impl ConnectorStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Connected => "CONNECTED",
            Self::Disconnected => "DISCONNECTED",
            Self::Connecting => "CONNECTING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONNECTED" => Some(Self::Connected),
            "DISCONNECTED" => Some(Self::Disconnected),
            "CONNECTING" => Some(Self::Connecting),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConnectorManageAction {
    Add = 0,
    Remove = 1,
}
impl ConnectorManageAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Add => "ADD",
            Self::Remove => "REMOVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ADD" => Some(Self::Add),
            "REMOVE" => Some(Self::Remove),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TcpProxyEntryTransportType {
    Tcp = 0,
    Kcp = 1,
}
impl TcpProxyEntryTransportType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Tcp => "TCP",
            Self::Kcp => "KCP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TCP" => Some(Self::Tcp),
            "KCP" => Some(Self::Kcp),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TcpProxyEntryState {
    Unknown = 0,
    /// receive syn packet but not start connecting to dst
    SynReceived = 1,
    /// connecting to dst
    ConnectingDst = 2,
    /// connected to dst
    Connected = 3,
    /// connection closed
    Closed = 4,
    /// closing src
    ClosingSrc = 5,
    /// closing dst
    ClosingDst = 6,
}
impl TcpProxyEntryState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::SynReceived => "SynReceived",
            Self::ConnectingDst => "ConnectingDst",
            Self::Connected => "Connected",
            Self::Closed => "Closed",
            Self::ClosingSrc => "ClosingSrc",
            Self::ClosingDst => "ClosingDst",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "SynReceived" => Some(Self::SynReceived),
            "ConnectingDst" => Some(Self::ConnectingDst),
            "Connected" => Some(Self::Connected),
            "Closed" => Some(Self::Closed),
            "ClosingSrc" => Some(Self::ClosingSrc),
            "ClosingDst" => Some(Self::ClosingDst),
            _ => None,
        }
    }
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait PeerManageRpc {
    type Controller: crate::proto::rpc_types::controller::Controller;
    async fn list_peer(
        &self,
        ctrl: Self::Controller,
        input: ListPeerRequest,
    ) -> crate::proto::rpc_types::error::Result<ListPeerResponse>;
    async fn list_route(
        &self,
        ctrl: Self::Controller,
        input: ListRouteRequest,
    ) -> crate::proto::rpc_types::error::Result<ListRouteResponse>;
    async fn dump_route(
        &self,
        ctrl: Self::Controller,
        input: DumpRouteRequest,
    ) -> crate::proto::rpc_types::error::Result<DumpRouteResponse>;
    async fn list_foreign_network(
        &self,
        ctrl: Self::Controller,
        input: ListForeignNetworkRequest,
    ) -> crate::proto::rpc_types::error::Result<ListForeignNetworkResponse>;
    async fn list_global_foreign_network(
        &self,
        ctrl: Self::Controller,
        input: ListGlobalForeignNetworkRequest,
    ) -> crate::proto::rpc_types::error::Result<ListGlobalForeignNetworkResponse>;
    async fn show_node_info(
        &self,
        ctrl: Self::Controller,
        input: ShowNodeInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<ShowNodeInfoResponse>;
}
/// A service descriptor for a `PeerManageRpc`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct PeerManageRpcDescriptor;
/// Methods available on a `PeerManageRpc`.
///
/// This can be used as a key when routing requests for servers/clients of a `PeerManageRpc`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum PeerManageRpcMethodDescriptor {
    ListPeer = 1,
    ListRoute = 2,
    DumpRoute = 3,
    ListForeignNetwork = 4,
    ListGlobalForeignNetwork = 5,
    ShowNodeInfo = 6,
}
impl std::convert::TryFrom<u8> for PeerManageRpcMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(PeerManageRpcMethodDescriptor::ListPeer),
            2 => Ok(PeerManageRpcMethodDescriptor::ListRoute),
            3 => Ok(PeerManageRpcMethodDescriptor::DumpRoute),
            4 => Ok(PeerManageRpcMethodDescriptor::ListForeignNetwork),
            5 => Ok(PeerManageRpcMethodDescriptor::ListGlobalForeignNetwork),
            6 => Ok(PeerManageRpcMethodDescriptor::ShowNodeInfo),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "PeerManageRpc".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `PeerManageRpc`.
///
/// This implements the `PeerManageRpc` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct PeerManageRpcClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> PeerManageRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = PeerManageRpcDescriptor>,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> PeerManageRpcClient<H> {
        PeerManageRpcClient(handler)
    }
}
impl<H> PeerManageRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = PeerManageRpcDescriptor>,
{
    async fn list_peer_inner(
        handler: H,
        ctrl: H::Controller,
        input: ListPeerRequest,
    ) -> crate::proto::rpc_types::error::Result<ListPeerResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                PeerManageRpcMethodDescriptor::ListPeer,
                input,
            )
            .await
    }
    async fn list_route_inner(
        handler: H,
        ctrl: H::Controller,
        input: ListRouteRequest,
    ) -> crate::proto::rpc_types::error::Result<ListRouteResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                PeerManageRpcMethodDescriptor::ListRoute,
                input,
            )
            .await
    }
    async fn dump_route_inner(
        handler: H,
        ctrl: H::Controller,
        input: DumpRouteRequest,
    ) -> crate::proto::rpc_types::error::Result<DumpRouteResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                PeerManageRpcMethodDescriptor::DumpRoute,
                input,
            )
            .await
    }
    async fn list_foreign_network_inner(
        handler: H,
        ctrl: H::Controller,
        input: ListForeignNetworkRequest,
    ) -> crate::proto::rpc_types::error::Result<ListForeignNetworkResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                PeerManageRpcMethodDescriptor::ListForeignNetwork,
                input,
            )
            .await
    }
    async fn list_global_foreign_network_inner(
        handler: H,
        ctrl: H::Controller,
        input: ListGlobalForeignNetworkRequest,
    ) -> crate::proto::rpc_types::error::Result<ListGlobalForeignNetworkResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                PeerManageRpcMethodDescriptor::ListGlobalForeignNetwork,
                input,
            )
            .await
    }
    async fn show_node_info_inner(
        handler: H,
        ctrl: H::Controller,
        input: ShowNodeInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<ShowNodeInfoResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                PeerManageRpcMethodDescriptor::ShowNodeInfo,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> PeerManageRpc for PeerManageRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = PeerManageRpcDescriptor>,
{
    type Controller = H::Controller;
    async fn list_peer(
        &self,
        ctrl: H::Controller,
        input: ListPeerRequest,
    ) -> crate::proto::rpc_types::error::Result<ListPeerResponse> {
        PeerManageRpcClient::list_peer_inner(self.0.clone(), ctrl, input).await
    }
    async fn list_route(
        &self,
        ctrl: H::Controller,
        input: ListRouteRequest,
    ) -> crate::proto::rpc_types::error::Result<ListRouteResponse> {
        PeerManageRpcClient::list_route_inner(self.0.clone(), ctrl, input).await
    }
    async fn dump_route(
        &self,
        ctrl: H::Controller,
        input: DumpRouteRequest,
    ) -> crate::proto::rpc_types::error::Result<DumpRouteResponse> {
        PeerManageRpcClient::dump_route_inner(self.0.clone(), ctrl, input).await
    }
    async fn list_foreign_network(
        &self,
        ctrl: H::Controller,
        input: ListForeignNetworkRequest,
    ) -> crate::proto::rpc_types::error::Result<ListForeignNetworkResponse> {
        PeerManageRpcClient::list_foreign_network_inner(self.0.clone(), ctrl, input)
            .await
    }
    async fn list_global_foreign_network(
        &self,
        ctrl: H::Controller,
        input: ListGlobalForeignNetworkRequest,
    ) -> crate::proto::rpc_types::error::Result<ListGlobalForeignNetworkResponse> {
        PeerManageRpcClient::list_global_foreign_network_inner(
                self.0.clone(),
                ctrl,
                input,
            )
            .await
    }
    async fn show_node_info(
        &self,
        ctrl: H::Controller,
        input: ShowNodeInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<ShowNodeInfoResponse> {
        PeerManageRpcClient::show_node_info_inner(self.0.clone(), ctrl, input).await
    }
}
pub struct PeerManageRpcClientFactory<
    C: crate::proto::rpc_types::controller::Controller,
>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for PeerManageRpcClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory for PeerManageRpcClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = PeerManageRpcDescriptor;
    type ClientImpl = Box<dyn PeerManageRpc<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(PeerManageRpcClient::new(handler))
    }
}
/// A server for a `PeerManageRpc`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `PeerManageRpc`.
#[derive(Clone, Debug)]
pub struct PeerManageRpcServer<A>(
    A,
)
where
    A: PeerManageRpc + Clone + Send + 'static;
impl<A> PeerManageRpcServer<A>
where
    A: PeerManageRpc + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> PeerManageRpcServer<A> {
        PeerManageRpcServer(service)
    }
    async fn call_inner(
        service: A,
        method: PeerManageRpcMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            PeerManageRpcMethodDescriptor::ListPeer => {
                let decoded: ListPeerRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.list_peer(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            PeerManageRpcMethodDescriptor::ListRoute => {
                let decoded: ListRouteRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.list_route(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            PeerManageRpcMethodDescriptor::DumpRoute => {
                let decoded: DumpRouteRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.dump_route(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            PeerManageRpcMethodDescriptor::ListForeignNetwork => {
                let decoded: ListForeignNetworkRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.list_foreign_network(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            PeerManageRpcMethodDescriptor::ListGlobalForeignNetwork => {
                let decoded: ListGlobalForeignNetworkRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.list_global_foreign_network(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            PeerManageRpcMethodDescriptor::ShowNodeInfo => {
                let decoded: ShowNodeInfoRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.show_node_info(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor for PeerManageRpcDescriptor {
    type Method = PeerManageRpcMethodDescriptor;
    fn name(&self) -> &'static str {
        "PeerManageRpc"
    }
    fn proto_name(&self) -> &'static str {
        "PeerManageRpc"
    }
    fn package(&self) -> &'static str {
        "cli"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[
            PeerManageRpcMethodDescriptor::ListPeer,
            PeerManageRpcMethodDescriptor::ListRoute,
            PeerManageRpcMethodDescriptor::DumpRoute,
            PeerManageRpcMethodDescriptor::ListForeignNetwork,
            PeerManageRpcMethodDescriptor::ListGlobalForeignNetwork,
            PeerManageRpcMethodDescriptor::ShowNodeInfo,
        ]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for PeerManageRpcServer<A>
where
    A: PeerManageRpc + Clone + Send + Sync + 'static,
{
    type Descriptor = PeerManageRpcDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: PeerManageRpcMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        PeerManageRpcServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor
for PeerManageRpcMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            PeerManageRpcMethodDescriptor::ListPeer => "list_peer",
            PeerManageRpcMethodDescriptor::ListRoute => "list_route",
            PeerManageRpcMethodDescriptor::DumpRoute => "dump_route",
            PeerManageRpcMethodDescriptor::ListForeignNetwork => "list_foreign_network",
            PeerManageRpcMethodDescriptor::ListGlobalForeignNetwork => {
                "list_global_foreign_network"
            }
            PeerManageRpcMethodDescriptor::ShowNodeInfo => "show_node_info",
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            PeerManageRpcMethodDescriptor::ListPeer => "ListPeer",
            PeerManageRpcMethodDescriptor::ListRoute => "ListRoute",
            PeerManageRpcMethodDescriptor::DumpRoute => "DumpRoute",
            PeerManageRpcMethodDescriptor::ListForeignNetwork => "ListForeignNetwork",
            PeerManageRpcMethodDescriptor::ListGlobalForeignNetwork => {
                "ListGlobalForeignNetwork"
            }
            PeerManageRpcMethodDescriptor::ShowNodeInfo => "ShowNodeInfo",
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            PeerManageRpcMethodDescriptor::ListPeer => {
                ::std::any::TypeId::of::<ListPeerRequest>()
            }
            PeerManageRpcMethodDescriptor::ListRoute => {
                ::std::any::TypeId::of::<ListRouteRequest>()
            }
            PeerManageRpcMethodDescriptor::DumpRoute => {
                ::std::any::TypeId::of::<DumpRouteRequest>()
            }
            PeerManageRpcMethodDescriptor::ListForeignNetwork => {
                ::std::any::TypeId::of::<ListForeignNetworkRequest>()
            }
            PeerManageRpcMethodDescriptor::ListGlobalForeignNetwork => {
                ::std::any::TypeId::of::<ListGlobalForeignNetworkRequest>()
            }
            PeerManageRpcMethodDescriptor::ShowNodeInfo => {
                ::std::any::TypeId::of::<ShowNodeInfoRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            PeerManageRpcMethodDescriptor::ListPeer => ".cli.ListPeerRequest",
            PeerManageRpcMethodDescriptor::ListRoute => ".cli.ListRouteRequest",
            PeerManageRpcMethodDescriptor::DumpRoute => ".cli.DumpRouteRequest",
            PeerManageRpcMethodDescriptor::ListForeignNetwork => {
                ".cli.ListForeignNetworkRequest"
            }
            PeerManageRpcMethodDescriptor::ListGlobalForeignNetwork => {
                ".cli.ListGlobalForeignNetworkRequest"
            }
            PeerManageRpcMethodDescriptor::ShowNodeInfo => ".cli.ShowNodeInfoRequest",
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            PeerManageRpcMethodDescriptor::ListPeer => {
                ::std::any::TypeId::of::<ListPeerResponse>()
            }
            PeerManageRpcMethodDescriptor::ListRoute => {
                ::std::any::TypeId::of::<ListRouteResponse>()
            }
            PeerManageRpcMethodDescriptor::DumpRoute => {
                ::std::any::TypeId::of::<DumpRouteResponse>()
            }
            PeerManageRpcMethodDescriptor::ListForeignNetwork => {
                ::std::any::TypeId::of::<ListForeignNetworkResponse>()
            }
            PeerManageRpcMethodDescriptor::ListGlobalForeignNetwork => {
                ::std::any::TypeId::of::<ListGlobalForeignNetworkResponse>()
            }
            PeerManageRpcMethodDescriptor::ShowNodeInfo => {
                ::std::any::TypeId::of::<ShowNodeInfoResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            PeerManageRpcMethodDescriptor::ListPeer => ".cli.ListPeerResponse",
            PeerManageRpcMethodDescriptor::ListRoute => ".cli.ListRouteResponse",
            PeerManageRpcMethodDescriptor::DumpRoute => ".cli.DumpRouteResponse",
            PeerManageRpcMethodDescriptor::ListForeignNetwork => {
                ".cli.ListForeignNetworkResponse"
            }
            PeerManageRpcMethodDescriptor::ListGlobalForeignNetwork => {
                ".cli.ListGlobalForeignNetworkResponse"
            }
            PeerManageRpcMethodDescriptor::ShowNodeInfo => ".cli.ShowNodeInfoResponse",
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait ConnectorManageRpc {
    type Controller: crate::proto::rpc_types::controller::Controller;
    async fn list_connector(
        &self,
        ctrl: Self::Controller,
        input: ListConnectorRequest,
    ) -> crate::proto::rpc_types::error::Result<ListConnectorResponse>;
    async fn manage_connector(
        &self,
        ctrl: Self::Controller,
        input: ManageConnectorRequest,
    ) -> crate::proto::rpc_types::error::Result<ManageConnectorResponse>;
}
/// A service descriptor for a `ConnectorManageRpc`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct ConnectorManageRpcDescriptor;
/// Methods available on a `ConnectorManageRpc`.
///
/// This can be used as a key when routing requests for servers/clients of a `ConnectorManageRpc`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum ConnectorManageRpcMethodDescriptor {
    ListConnector = 1,
    ManageConnector = 2,
}
impl std::convert::TryFrom<u8> for ConnectorManageRpcMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(ConnectorManageRpcMethodDescriptor::ListConnector),
            2 => Ok(ConnectorManageRpcMethodDescriptor::ManageConnector),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "ConnectorManageRpc".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `ConnectorManageRpc`.
///
/// This implements the `ConnectorManageRpc` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct ConnectorManageRpcClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> ConnectorManageRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = ConnectorManageRpcDescriptor,
    >,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> ConnectorManageRpcClient<H> {
        ConnectorManageRpcClient(handler)
    }
}
impl<H> ConnectorManageRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = ConnectorManageRpcDescriptor,
    >,
{
    async fn list_connector_inner(
        handler: H,
        ctrl: H::Controller,
        input: ListConnectorRequest,
    ) -> crate::proto::rpc_types::error::Result<ListConnectorResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                ConnectorManageRpcMethodDescriptor::ListConnector,
                input,
            )
            .await
    }
    async fn manage_connector_inner(
        handler: H,
        ctrl: H::Controller,
        input: ManageConnectorRequest,
    ) -> crate::proto::rpc_types::error::Result<ManageConnectorResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                ConnectorManageRpcMethodDescriptor::ManageConnector,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> ConnectorManageRpc for ConnectorManageRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = ConnectorManageRpcDescriptor,
    >,
{
    type Controller = H::Controller;
    async fn list_connector(
        &self,
        ctrl: H::Controller,
        input: ListConnectorRequest,
    ) -> crate::proto::rpc_types::error::Result<ListConnectorResponse> {
        ConnectorManageRpcClient::list_connector_inner(self.0.clone(), ctrl, input).await
    }
    async fn manage_connector(
        &self,
        ctrl: H::Controller,
        input: ManageConnectorRequest,
    ) -> crate::proto::rpc_types::error::Result<ManageConnectorResponse> {
        ConnectorManageRpcClient::manage_connector_inner(self.0.clone(), ctrl, input)
            .await
    }
}
pub struct ConnectorManageRpcClientFactory<
    C: crate::proto::rpc_types::controller::Controller,
>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for ConnectorManageRpcClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory
for ConnectorManageRpcClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = ConnectorManageRpcDescriptor;
    type ClientImpl = Box<dyn ConnectorManageRpc<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(ConnectorManageRpcClient::new(handler))
    }
}
/// A server for a `ConnectorManageRpc`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `ConnectorManageRpc`.
#[derive(Clone, Debug)]
pub struct ConnectorManageRpcServer<A>(
    A,
)
where
    A: ConnectorManageRpc + Clone + Send + 'static;
impl<A> ConnectorManageRpcServer<A>
where
    A: ConnectorManageRpc + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> ConnectorManageRpcServer<A> {
        ConnectorManageRpcServer(service)
    }
    async fn call_inner(
        service: A,
        method: ConnectorManageRpcMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            ConnectorManageRpcMethodDescriptor::ListConnector => {
                let decoded: ListConnectorRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.list_connector(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            ConnectorManageRpcMethodDescriptor::ManageConnector => {
                let decoded: ManageConnectorRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.manage_connector(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor
for ConnectorManageRpcDescriptor {
    type Method = ConnectorManageRpcMethodDescriptor;
    fn name(&self) -> &'static str {
        "ConnectorManageRpc"
    }
    fn proto_name(&self) -> &'static str {
        "ConnectorManageRpc"
    }
    fn package(&self) -> &'static str {
        "cli"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[
            ConnectorManageRpcMethodDescriptor::ListConnector,
            ConnectorManageRpcMethodDescriptor::ManageConnector,
        ]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for ConnectorManageRpcServer<A>
where
    A: ConnectorManageRpc + Clone + Send + Sync + 'static,
{
    type Descriptor = ConnectorManageRpcDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: ConnectorManageRpcMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        ConnectorManageRpcServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor
for ConnectorManageRpcMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            ConnectorManageRpcMethodDescriptor::ListConnector => "list_connector",
            ConnectorManageRpcMethodDescriptor::ManageConnector => "manage_connector",
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            ConnectorManageRpcMethodDescriptor::ListConnector => "ListConnector",
            ConnectorManageRpcMethodDescriptor::ManageConnector => "ManageConnector",
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            ConnectorManageRpcMethodDescriptor::ListConnector => {
                ::std::any::TypeId::of::<ListConnectorRequest>()
            }
            ConnectorManageRpcMethodDescriptor::ManageConnector => {
                ::std::any::TypeId::of::<ManageConnectorRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            ConnectorManageRpcMethodDescriptor::ListConnector => {
                ".cli.ListConnectorRequest"
            }
            ConnectorManageRpcMethodDescriptor::ManageConnector => {
                ".cli.ManageConnectorRequest"
            }
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            ConnectorManageRpcMethodDescriptor::ListConnector => {
                ::std::any::TypeId::of::<ListConnectorResponse>()
            }
            ConnectorManageRpcMethodDescriptor::ManageConnector => {
                ::std::any::TypeId::of::<ManageConnectorResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            ConnectorManageRpcMethodDescriptor::ListConnector => {
                ".cli.ListConnectorResponse"
            }
            ConnectorManageRpcMethodDescriptor::ManageConnector => {
                ".cli.ManageConnectorResponse"
            }
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait VpnPortalRpc {
    type Controller: crate::proto::rpc_types::controller::Controller;
    async fn get_vpn_portal_info(
        &self,
        ctrl: Self::Controller,
        input: GetVpnPortalInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<GetVpnPortalInfoResponse>;
}
/// A service descriptor for a `VpnPortalRpc`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct VpnPortalRpcDescriptor;
/// Methods available on a `VpnPortalRpc`.
///
/// This can be used as a key when routing requests for servers/clients of a `VpnPortalRpc`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum VpnPortalRpcMethodDescriptor {
    GetVpnPortalInfo = 1,
}
impl std::convert::TryFrom<u8> for VpnPortalRpcMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(VpnPortalRpcMethodDescriptor::GetVpnPortalInfo),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "VpnPortalRpc".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `VpnPortalRpc`.
///
/// This implements the `VpnPortalRpc` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct VpnPortalRpcClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> VpnPortalRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = VpnPortalRpcDescriptor>,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> VpnPortalRpcClient<H> {
        VpnPortalRpcClient(handler)
    }
}
impl<H> VpnPortalRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = VpnPortalRpcDescriptor>,
{
    async fn get_vpn_portal_info_inner(
        handler: H,
        ctrl: H::Controller,
        input: GetVpnPortalInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<GetVpnPortalInfoResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                VpnPortalRpcMethodDescriptor::GetVpnPortalInfo,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> VpnPortalRpc for VpnPortalRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = VpnPortalRpcDescriptor>,
{
    type Controller = H::Controller;
    async fn get_vpn_portal_info(
        &self,
        ctrl: H::Controller,
        input: GetVpnPortalInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<GetVpnPortalInfoResponse> {
        VpnPortalRpcClient::get_vpn_portal_info_inner(self.0.clone(), ctrl, input).await
    }
}
pub struct VpnPortalRpcClientFactory<C: crate::proto::rpc_types::controller::Controller>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for VpnPortalRpcClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory for VpnPortalRpcClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = VpnPortalRpcDescriptor;
    type ClientImpl = Box<dyn VpnPortalRpc<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(VpnPortalRpcClient::new(handler))
    }
}
/// A server for a `VpnPortalRpc`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `VpnPortalRpc`.
#[derive(Clone, Debug)]
pub struct VpnPortalRpcServer<A>(
    A,
)
where
    A: VpnPortalRpc + Clone + Send + 'static;
impl<A> VpnPortalRpcServer<A>
where
    A: VpnPortalRpc + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> VpnPortalRpcServer<A> {
        VpnPortalRpcServer(service)
    }
    async fn call_inner(
        service: A,
        method: VpnPortalRpcMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            VpnPortalRpcMethodDescriptor::GetVpnPortalInfo => {
                let decoded: GetVpnPortalInfoRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.get_vpn_portal_info(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor for VpnPortalRpcDescriptor {
    type Method = VpnPortalRpcMethodDescriptor;
    fn name(&self) -> &'static str {
        "VpnPortalRpc"
    }
    fn proto_name(&self) -> &'static str {
        "VpnPortalRpc"
    }
    fn package(&self) -> &'static str {
        "cli"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[VpnPortalRpcMethodDescriptor::GetVpnPortalInfo]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for VpnPortalRpcServer<A>
where
    A: VpnPortalRpc + Clone + Send + Sync + 'static,
{
    type Descriptor = VpnPortalRpcDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: VpnPortalRpcMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        VpnPortalRpcServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor
for VpnPortalRpcMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            VpnPortalRpcMethodDescriptor::GetVpnPortalInfo => "get_vpn_portal_info",
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            VpnPortalRpcMethodDescriptor::GetVpnPortalInfo => "GetVpnPortalInfo",
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            VpnPortalRpcMethodDescriptor::GetVpnPortalInfo => {
                ::std::any::TypeId::of::<GetVpnPortalInfoRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            VpnPortalRpcMethodDescriptor::GetVpnPortalInfo => {
                ".cli.GetVpnPortalInfoRequest"
            }
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            VpnPortalRpcMethodDescriptor::GetVpnPortalInfo => {
                ::std::any::TypeId::of::<GetVpnPortalInfoResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            VpnPortalRpcMethodDescriptor::GetVpnPortalInfo => {
                ".cli.GetVpnPortalInfoResponse"
            }
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait TcpProxyRpc {
    type Controller: crate::proto::rpc_types::controller::Controller;
    async fn list_tcp_proxy_entry(
        &self,
        ctrl: Self::Controller,
        input: ListTcpProxyEntryRequest,
    ) -> crate::proto::rpc_types::error::Result<ListTcpProxyEntryResponse>;
}
/// A service descriptor for a `TcpProxyRpc`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct TcpProxyRpcDescriptor;
/// Methods available on a `TcpProxyRpc`.
///
/// This can be used as a key when routing requests for servers/clients of a `TcpProxyRpc`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum TcpProxyRpcMethodDescriptor {
    ListTcpProxyEntry = 1,
}
impl std::convert::TryFrom<u8> for TcpProxyRpcMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(TcpProxyRpcMethodDescriptor::ListTcpProxyEntry),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "TcpProxyRpc".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `TcpProxyRpc`.
///
/// This implements the `TcpProxyRpc` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct TcpProxyRpcClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> TcpProxyRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = TcpProxyRpcDescriptor>,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> TcpProxyRpcClient<H> {
        TcpProxyRpcClient(handler)
    }
}
impl<H> TcpProxyRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = TcpProxyRpcDescriptor>,
{
    async fn list_tcp_proxy_entry_inner(
        handler: H,
        ctrl: H::Controller,
        input: ListTcpProxyEntryRequest,
    ) -> crate::proto::rpc_types::error::Result<ListTcpProxyEntryResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                TcpProxyRpcMethodDescriptor::ListTcpProxyEntry,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> TcpProxyRpc for TcpProxyRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = TcpProxyRpcDescriptor>,
{
    type Controller = H::Controller;
    async fn list_tcp_proxy_entry(
        &self,
        ctrl: H::Controller,
        input: ListTcpProxyEntryRequest,
    ) -> crate::proto::rpc_types::error::Result<ListTcpProxyEntryResponse> {
        TcpProxyRpcClient::list_tcp_proxy_entry_inner(self.0.clone(), ctrl, input).await
    }
}
pub struct TcpProxyRpcClientFactory<C: crate::proto::rpc_types::controller::Controller>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for TcpProxyRpcClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory for TcpProxyRpcClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = TcpProxyRpcDescriptor;
    type ClientImpl = Box<dyn TcpProxyRpc<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(TcpProxyRpcClient::new(handler))
    }
}
/// A server for a `TcpProxyRpc`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `TcpProxyRpc`.
#[derive(Clone, Debug)]
pub struct TcpProxyRpcServer<A>(
    A,
)
where
    A: TcpProxyRpc + Clone + Send + 'static;
impl<A> TcpProxyRpcServer<A>
where
    A: TcpProxyRpc + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> TcpProxyRpcServer<A> {
        TcpProxyRpcServer(service)
    }
    async fn call_inner(
        service: A,
        method: TcpProxyRpcMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            TcpProxyRpcMethodDescriptor::ListTcpProxyEntry => {
                let decoded: ListTcpProxyEntryRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.list_tcp_proxy_entry(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor for TcpProxyRpcDescriptor {
    type Method = TcpProxyRpcMethodDescriptor;
    fn name(&self) -> &'static str {
        "TcpProxyRpc"
    }
    fn proto_name(&self) -> &'static str {
        "TcpProxyRpc"
    }
    fn package(&self) -> &'static str {
        "cli"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[TcpProxyRpcMethodDescriptor::ListTcpProxyEntry]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for TcpProxyRpcServer<A>
where
    A: TcpProxyRpc + Clone + Send + Sync + 'static,
{
    type Descriptor = TcpProxyRpcDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: TcpProxyRpcMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        TcpProxyRpcServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor
for TcpProxyRpcMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            TcpProxyRpcMethodDescriptor::ListTcpProxyEntry => "list_tcp_proxy_entry",
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            TcpProxyRpcMethodDescriptor::ListTcpProxyEntry => "ListTcpProxyEntry",
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            TcpProxyRpcMethodDescriptor::ListTcpProxyEntry => {
                ::std::any::TypeId::of::<ListTcpProxyEntryRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            TcpProxyRpcMethodDescriptor::ListTcpProxyEntry => {
                ".cli.ListTcpProxyEntryRequest"
            }
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            TcpProxyRpcMethodDescriptor::ListTcpProxyEntry => {
                ::std::any::TypeId::of::<ListTcpProxyEntryResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            TcpProxyRpcMethodDescriptor::ListTcpProxyEntry => {
                ".cli.ListTcpProxyEntryResponse"
            }
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
