// This file is @generated by prost-build.
/// The request for an `Greeting.SayHello` call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SayHelloRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The response for an `Greeting.SayHello` call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SayHelloResponse {
    #[prost(string, tag = "1")]
    pub greeting: ::prost::alloc::string::String,
}
/// The request for an `Greeting.SayGoodbye` call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SayGoodbyeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The response for an `Greeting.SayGoodbye` call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SayGoodbyeResponse {
    #[prost(string, tag = "1")]
    pub greeting: ::prost::alloc::string::String,
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait Greeting {
    type Controller: crate::proto::rpc_types::controller::Controller;
    /// Generates a "hello" greeting based on the supplied info.
    async fn say_hello(
        &self,
        ctrl: Self::Controller,
        input: SayHelloRequest,
    ) -> crate::proto::rpc_types::error::Result<SayHelloResponse>;
    /// Generates a "goodbye" greeting based on the supplied info.
    async fn say_goodbye(
        &self,
        ctrl: Self::Controller,
        input: SayGoodbyeRequest,
    ) -> crate::proto::rpc_types::error::Result<SayGoodbyeResponse>;
}
/// A service descriptor for a `Greeting`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct GreetingDescriptor;
/// Methods available on a `Greeting`.
///
/// This can be used as a key when routing requests for servers/clients of a `Greeting`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum GreetingMethodDescriptor {
    /// Generates a "hello" greeting based on the supplied info.
    SayHello = 1,
    /// Generates a "goodbye" greeting based on the supplied info.
    SayGoodbye = 2,
}
impl std::convert::TryFrom<u8> for GreetingMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(GreetingMethodDescriptor::SayHello),
            2 => Ok(GreetingMethodDescriptor::SayGoodbye),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "Greeting".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `Greeting`.
///
/// This implements the `Greeting` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct GreetingClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> GreetingClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = GreetingDescriptor>,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> GreetingClient<H> {
        GreetingClient(handler)
    }
}
impl<H> GreetingClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = GreetingDescriptor>,
{
    async fn say_hello_inner(
        handler: H,
        ctrl: H::Controller,
        input: SayHelloRequest,
    ) -> crate::proto::rpc_types::error::Result<SayHelloResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                GreetingMethodDescriptor::SayHello,
                input,
            )
            .await
    }
    async fn say_goodbye_inner(
        handler: H,
        ctrl: H::Controller,
        input: SayGoodbyeRequest,
    ) -> crate::proto::rpc_types::error::Result<SayGoodbyeResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                GreetingMethodDescriptor::SayGoodbye,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> Greeting for GreetingClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = GreetingDescriptor>,
{
    type Controller = H::Controller;
    async fn say_hello(
        &self,
        ctrl: H::Controller,
        input: SayHelloRequest,
    ) -> crate::proto::rpc_types::error::Result<SayHelloResponse> {
        GreetingClient::say_hello_inner(self.0.clone(), ctrl, input).await
    }
    async fn say_goodbye(
        &self,
        ctrl: H::Controller,
        input: SayGoodbyeRequest,
    ) -> crate::proto::rpc_types::error::Result<SayGoodbyeResponse> {
        GreetingClient::say_goodbye_inner(self.0.clone(), ctrl, input).await
    }
}
pub struct GreetingClientFactory<C: crate::proto::rpc_types::controller::Controller>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for GreetingClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory for GreetingClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = GreetingDescriptor;
    type ClientImpl = Box<dyn Greeting<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(GreetingClient::new(handler))
    }
}
/// A server for a `Greeting`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `Greeting`.
#[derive(Clone, Debug)]
pub struct GreetingServer<A>(
    A,
)
where
    A: Greeting + Clone + Send + 'static;
impl<A> GreetingServer<A>
where
    A: Greeting + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> GreetingServer<A> {
        GreetingServer(service)
    }
    async fn call_inner(
        service: A,
        method: GreetingMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            GreetingMethodDescriptor::SayHello => {
                let decoded: SayHelloRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.say_hello(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            GreetingMethodDescriptor::SayGoodbye => {
                let decoded: SayGoodbyeRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.say_goodbye(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor for GreetingDescriptor {
    type Method = GreetingMethodDescriptor;
    fn name(&self) -> &'static str {
        "Greeting"
    }
    fn proto_name(&self) -> &'static str {
        "Greeting"
    }
    fn package(&self) -> &'static str {
        "tests"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[GreetingMethodDescriptor::SayHello, GreetingMethodDescriptor::SayGoodbye]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for GreetingServer<A>
where
    A: Greeting + Clone + Send + Sync + 'static,
{
    type Descriptor = GreetingDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: GreetingMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        GreetingServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor for GreetingMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            GreetingMethodDescriptor::SayHello => "say_hello",
            GreetingMethodDescriptor::SayGoodbye => "say_goodbye",
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            GreetingMethodDescriptor::SayHello => "SayHello",
            GreetingMethodDescriptor::SayGoodbye => "SayGoodbye",
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            GreetingMethodDescriptor::SayHello => {
                ::std::any::TypeId::of::<SayHelloRequest>()
            }
            GreetingMethodDescriptor::SayGoodbye => {
                ::std::any::TypeId::of::<SayGoodbyeRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            GreetingMethodDescriptor::SayHello => ".tests.SayHelloRequest",
            GreetingMethodDescriptor::SayGoodbye => ".tests.SayGoodbyeRequest",
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            GreetingMethodDescriptor::SayHello => {
                ::std::any::TypeId::of::<SayHelloResponse>()
            }
            GreetingMethodDescriptor::SayGoodbye => {
                ::std::any::TypeId::of::<SayGoodbyeResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            GreetingMethodDescriptor::SayHello => ".tests.SayHelloResponse",
            GreetingMethodDescriptor::SayGoodbye => ".tests.SayGoodbyeResponse",
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
