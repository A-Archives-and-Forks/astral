// This file is @generated by prost-build.
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.RoutePeerInfo")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutePeerInfo {
    /// means next hop in route table.
    #[prost(uint32, tag = "1")]
    pub peer_id: u32,
    #[prost(message, optional, tag = "2")]
    pub inst_id: ::core::option::Option<super::common::Uuid>,
    #[prost(uint32, tag = "3")]
    pub cost: u32,
    #[prost(message, optional, tag = "4")]
    pub ipv4_addr: ::core::option::Option<super::common::Ipv4Addr>,
    #[prost(string, repeated, tag = "5")]
    pub proxy_cidrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "super::common::NatType", tag = "7")]
    pub udp_stun_info: i32,
    #[prost(message, optional, tag = "8")]
    pub last_update: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint32, tag = "9")]
    pub version: u32,
    #[prost(string, tag = "10")]
    pub easytier_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub feature_flag: ::core::option::Option<super::common::PeerFeatureFlag>,
    #[prost(uint64, tag = "12")]
    pub peer_route_id: u64,
    #[prost(uint32, tag = "13")]
    pub network_length: u32,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.PeerIdVersion")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PeerIdVersion {
    #[prost(uint32, tag = "1")]
    pub peer_id: u32,
    #[prost(uint32, tag = "2")]
    pub version: u32,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.RouteConnBitmap")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteConnBitmap {
    #[prost(message, repeated, tag = "1")]
    pub peer_ids: ::prost::alloc::vec::Vec<PeerIdVersion>,
    #[prost(bytes = "vec", tag = "2")]
    pub bitmap: ::prost::alloc::vec::Vec<u8>,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.RoutePeerInfos")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutePeerInfos {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<RoutePeerInfo>,
}
#[derive(Hash, Eq)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.ForeignNetworkRouteInfoKey")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForeignNetworkRouteInfoKey {
    #[prost(uint32, tag = "1")]
    pub peer_id: u32,
    #[prost(string, tag = "2")]
    pub network_name: ::prost::alloc::string::String,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.ForeignNetworkRouteInfoEntry")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForeignNetworkRouteInfoEntry {
    #[prost(uint32, repeated, tag = "1")]
    pub foreign_peer_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "2")]
    pub last_update: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint32, tag = "3")]
    pub version: u32,
    #[prost(bytes = "vec", tag = "4")]
    pub network_secret_digest: ::prost::alloc::vec::Vec<u8>,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.RouteForeignNetworkInfos")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteForeignNetworkInfos {
    #[prost(message, repeated, tag = "1")]
    pub infos: ::prost::alloc::vec::Vec<route_foreign_network_infos::Info>,
}
/// Nested message and enum types in `RouteForeignNetworkInfos`.
pub mod route_foreign_network_infos {
    #[derive(::prost_reflect::ReflectMessage)]
    #[prost_reflect(message_name = "peer_rpc.RouteForeignNetworkInfos.Info")]
    #[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Info {
        #[prost(message, optional, tag = "1")]
        pub key: ::core::option::Option<super::ForeignNetworkRouteInfoKey>,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<super::ForeignNetworkRouteInfoEntry>,
    }
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.SyncRouteInfoRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncRouteInfoRequest {
    #[prost(uint32, tag = "1")]
    pub my_peer_id: u32,
    #[prost(uint64, tag = "2")]
    pub my_session_id: u64,
    #[prost(bool, tag = "3")]
    pub is_initiator: bool,
    #[prost(message, optional, tag = "4")]
    pub peer_infos: ::core::option::Option<RoutePeerInfos>,
    #[prost(message, optional, tag = "5")]
    pub conn_bitmap: ::core::option::Option<RouteConnBitmap>,
    #[prost(message, optional, tag = "6")]
    pub foreign_network_infos: ::core::option::Option<RouteForeignNetworkInfos>,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.SyncRouteInfoResponse")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SyncRouteInfoResponse {
    #[prost(bool, tag = "1")]
    pub is_initiator: bool,
    #[prost(uint64, tag = "2")]
    pub session_id: u64,
    #[prost(enumeration = "SyncRouteInfoError", optional, tag = "3")]
    pub error: ::core::option::Option<i32>,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.GetIpListRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetIpListRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.GetIpListResponse")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIpListResponse {
    #[prost(message, optional, tag = "1")]
    pub public_ipv4: ::core::option::Option<super::common::Ipv4Addr>,
    #[prost(message, repeated, tag = "2")]
    pub interface_ipv4s: ::prost::alloc::vec::Vec<super::common::Ipv4Addr>,
    #[prost(message, optional, tag = "3")]
    pub public_ipv6: ::core::option::Option<super::common::Ipv6Addr>,
    #[prost(message, repeated, tag = "4")]
    pub interface_ipv6s: ::prost::alloc::vec::Vec<super::common::Ipv6Addr>,
    #[prost(message, repeated, tag = "5")]
    pub listeners: ::prost::alloc::vec::Vec<super::common::Url>,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.SelectPunchListenerRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectPunchListenerRequest {
    #[prost(bool, tag = "1")]
    pub force_new: bool,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.SelectPunchListenerResponse")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectPunchListenerResponse {
    #[prost(message, optional, tag = "1")]
    pub listener_mapped_addr: ::core::option::Option<super::common::SocketAddr>,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.SendPunchPacketConeRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendPunchPacketConeRequest {
    #[prost(message, optional, tag = "1")]
    pub listener_mapped_addr: ::core::option::Option<super::common::SocketAddr>,
    #[prost(message, optional, tag = "2")]
    pub dest_addr: ::core::option::Option<super::common::SocketAddr>,
    #[prost(uint32, tag = "3")]
    pub transaction_id: u32,
    /// send this many packets in a batch
    #[prost(uint32, tag = "4")]
    pub packet_count_per_batch: u32,
    /// send total this batch count, total packet count = packet_batch_size * packet_batch_count
    #[prost(uint32, tag = "5")]
    pub packet_batch_count: u32,
    /// interval between each batch
    #[prost(uint32, tag = "6")]
    pub packet_interval_ms: u32,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.SendPunchPacketHardSymRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendPunchPacketHardSymRequest {
    #[prost(message, optional, tag = "1")]
    pub listener_mapped_addr: ::core::option::Option<super::common::SocketAddr>,
    #[prost(message, repeated, tag = "2")]
    pub public_ips: ::prost::alloc::vec::Vec<super::common::Ipv4Addr>,
    #[prost(uint32, tag = "3")]
    pub transaction_id: u32,
    #[prost(uint32, tag = "4")]
    pub port_index: u32,
    #[prost(uint32, tag = "5")]
    pub round: u32,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.SendPunchPacketHardSymResponse")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendPunchPacketHardSymResponse {
    #[prost(uint32, tag = "1")]
    pub next_port_index: u32,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.SendPunchPacketEasySymRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendPunchPacketEasySymRequest {
    #[prost(message, optional, tag = "1")]
    pub listener_mapped_addr: ::core::option::Option<super::common::SocketAddr>,
    #[prost(message, repeated, tag = "2")]
    pub public_ips: ::prost::alloc::vec::Vec<super::common::Ipv4Addr>,
    #[prost(uint32, tag = "3")]
    pub transaction_id: u32,
    #[prost(uint32, tag = "4")]
    pub base_port_num: u32,
    #[prost(uint32, tag = "5")]
    pub max_port_num: u32,
    #[prost(bool, tag = "6")]
    pub is_incremental: bool,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.SendPunchPacketBothEasySymRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendPunchPacketBothEasySymRequest {
    #[prost(uint32, tag = "1")]
    pub udp_socket_count: u32,
    #[prost(message, optional, tag = "2")]
    pub public_ip: ::core::option::Option<super::common::Ipv4Addr>,
    #[prost(uint32, tag = "3")]
    pub transaction_id: u32,
    #[prost(uint32, tag = "4")]
    pub dst_port_num: u32,
    #[prost(uint32, tag = "5")]
    pub wait_time_ms: u32,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.SendPunchPacketBothEasySymResponse")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendPunchPacketBothEasySymResponse {
    /// is doing punch with other peer
    #[prost(bool, tag = "1")]
    pub is_busy: bool,
    #[prost(message, optional, tag = "2")]
    pub base_mapped_addr: ::core::option::Option<super::common::SocketAddr>,
}
#[derive(Hash)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.DirectConnectedPeerInfo")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DirectConnectedPeerInfo {
    #[prost(int32, tag = "1")]
    pub latency_ms: i32,
}
#[derive(Hash)]
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.PeerInfoForGlobalMap")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerInfoForGlobalMap {
    #[prost(btree_map = "uint32, message", tag = "1")]
    pub direct_peers: ::prost::alloc::collections::BTreeMap<
        u32,
        DirectConnectedPeerInfo,
    >,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.ReportPeersRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportPeersRequest {
    #[prost(uint32, tag = "1")]
    pub my_peer_id: u32,
    #[prost(message, optional, tag = "2")]
    pub peer_infos: ::core::option::Option<PeerInfoForGlobalMap>,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.ReportPeersResponse")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReportPeersResponse {}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.GlobalPeerMap")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalPeerMap {
    #[prost(btree_map = "uint32, message", tag = "1")]
    pub map: ::prost::alloc::collections::BTreeMap<u32, PeerInfoForGlobalMap>,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.GetGlobalPeerMapRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGlobalPeerMapRequest {
    #[prost(uint64, tag = "1")]
    pub digest: u64,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.GetGlobalPeerMapResponse")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalPeerMapResponse {
    #[prost(btree_map = "uint32, message", tag = "1")]
    pub global_peer_map: ::prost::alloc::collections::BTreeMap<
        u32,
        PeerInfoForGlobalMap,
    >,
    #[prost(uint64, optional, tag = "2")]
    pub digest: ::core::option::Option<u64>,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.HandshakeRequest")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HandshakeRequest {
    #[prost(uint32, tag = "1")]
    pub magic: u32,
    #[prost(uint32, tag = "2")]
    pub my_peer_id: u32,
    #[prost(uint32, tag = "3")]
    pub version: u32,
    #[prost(string, repeated, tag = "4")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub network_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "6")]
    pub network_secret_digrest: ::prost::alloc::vec::Vec<u8>,
}
#[derive(::prost_reflect::ReflectMessage)]
#[prost_reflect(message_name = "peer_rpc.KcpConnData")]
#[prost_reflect(file_descriptor_set_bytes = "crate::proto::DESCRIPTOR_POOL_BYTES")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KcpConnData {
    #[prost(message, optional, tag = "1")]
    pub src: ::core::option::Option<super::common::SocketAddr>,
    #[prost(message, optional, tag = "4")]
    pub dst: ::core::option::Option<super::common::SocketAddr>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SyncRouteInfoError {
    DuplicatePeerId = 0,
    Stopped = 1,
}
impl SyncRouteInfoError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DuplicatePeerId => "DuplicatePeerId",
            Self::Stopped => "Stopped",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DuplicatePeerId" => Some(Self::DuplicatePeerId),
            "Stopped" => Some(Self::Stopped),
            _ => None,
        }
    }
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait OspfRouteRpc {
    type Controller: crate::proto::rpc_types::controller::Controller;
    /// Generates a "hello" greeting based on the supplied info.
    async fn sync_route_info(
        &self,
        ctrl: Self::Controller,
        input: SyncRouteInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<SyncRouteInfoResponse>;
}
/// A service descriptor for a `OspfRouteRpc`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct OspfRouteRpcDescriptor;
/// Methods available on a `OspfRouteRpc`.
///
/// This can be used as a key when routing requests for servers/clients of a `OspfRouteRpc`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum OspfRouteRpcMethodDescriptor {
    /// Generates a "hello" greeting based on the supplied info.
    SyncRouteInfo = 1,
}
impl std::convert::TryFrom<u8> for OspfRouteRpcMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(OspfRouteRpcMethodDescriptor::SyncRouteInfo),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "OspfRouteRpc".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `OspfRouteRpc`.
///
/// This implements the `OspfRouteRpc` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct OspfRouteRpcClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> OspfRouteRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = OspfRouteRpcDescriptor>,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> OspfRouteRpcClient<H> {
        OspfRouteRpcClient(handler)
    }
}
impl<H> OspfRouteRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = OspfRouteRpcDescriptor>,
{
    async fn sync_route_info_inner(
        handler: H,
        ctrl: H::Controller,
        input: SyncRouteInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<SyncRouteInfoResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                OspfRouteRpcMethodDescriptor::SyncRouteInfo,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> OspfRouteRpc for OspfRouteRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = OspfRouteRpcDescriptor>,
{
    type Controller = H::Controller;
    async fn sync_route_info(
        &self,
        ctrl: H::Controller,
        input: SyncRouteInfoRequest,
    ) -> crate::proto::rpc_types::error::Result<SyncRouteInfoResponse> {
        OspfRouteRpcClient::sync_route_info_inner(self.0.clone(), ctrl, input).await
    }
}
pub struct OspfRouteRpcClientFactory<C: crate::proto::rpc_types::controller::Controller>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for OspfRouteRpcClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory for OspfRouteRpcClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = OspfRouteRpcDescriptor;
    type ClientImpl = Box<dyn OspfRouteRpc<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(OspfRouteRpcClient::new(handler))
    }
}
/// A server for a `OspfRouteRpc`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `OspfRouteRpc`.
#[derive(Clone, Debug)]
pub struct OspfRouteRpcServer<A>(
    A,
)
where
    A: OspfRouteRpc + Clone + Send + 'static;
impl<A> OspfRouteRpcServer<A>
where
    A: OspfRouteRpc + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> OspfRouteRpcServer<A> {
        OspfRouteRpcServer(service)
    }
    async fn call_inner(
        service: A,
        method: OspfRouteRpcMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            OspfRouteRpcMethodDescriptor::SyncRouteInfo => {
                let decoded: SyncRouteInfoRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.sync_route_info(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor for OspfRouteRpcDescriptor {
    type Method = OspfRouteRpcMethodDescriptor;
    fn name(&self) -> &'static str {
        "OspfRouteRpc"
    }
    fn proto_name(&self) -> &'static str {
        "OspfRouteRpc"
    }
    fn package(&self) -> &'static str {
        "peer_rpc"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[OspfRouteRpcMethodDescriptor::SyncRouteInfo]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for OspfRouteRpcServer<A>
where
    A: OspfRouteRpc + Clone + Send + Sync + 'static,
{
    type Descriptor = OspfRouteRpcDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: OspfRouteRpcMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        OspfRouteRpcServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor
for OspfRouteRpcMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            OspfRouteRpcMethodDescriptor::SyncRouteInfo => "sync_route_info",
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            OspfRouteRpcMethodDescriptor::SyncRouteInfo => "SyncRouteInfo",
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            OspfRouteRpcMethodDescriptor::SyncRouteInfo => {
                ::std::any::TypeId::of::<SyncRouteInfoRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            OspfRouteRpcMethodDescriptor::SyncRouteInfo => {
                ".peer_rpc.SyncRouteInfoRequest"
            }
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            OspfRouteRpcMethodDescriptor::SyncRouteInfo => {
                ::std::any::TypeId::of::<SyncRouteInfoResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            OspfRouteRpcMethodDescriptor::SyncRouteInfo => {
                ".peer_rpc.SyncRouteInfoResponse"
            }
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait DirectConnectorRpc {
    type Controller: crate::proto::rpc_types::controller::Controller;
    async fn get_ip_list(
        &self,
        ctrl: Self::Controller,
        input: GetIpListRequest,
    ) -> crate::proto::rpc_types::error::Result<GetIpListResponse>;
}
/// A service descriptor for a `DirectConnectorRpc`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct DirectConnectorRpcDescriptor;
/// Methods available on a `DirectConnectorRpc`.
///
/// This can be used as a key when routing requests for servers/clients of a `DirectConnectorRpc`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum DirectConnectorRpcMethodDescriptor {
    GetIpList = 1,
}
impl std::convert::TryFrom<u8> for DirectConnectorRpcMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(DirectConnectorRpcMethodDescriptor::GetIpList),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "DirectConnectorRpc".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `DirectConnectorRpc`.
///
/// This implements the `DirectConnectorRpc` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct DirectConnectorRpcClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> DirectConnectorRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = DirectConnectorRpcDescriptor,
    >,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> DirectConnectorRpcClient<H> {
        DirectConnectorRpcClient(handler)
    }
}
impl<H> DirectConnectorRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = DirectConnectorRpcDescriptor,
    >,
{
    async fn get_ip_list_inner(
        handler: H,
        ctrl: H::Controller,
        input: GetIpListRequest,
    ) -> crate::proto::rpc_types::error::Result<GetIpListResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                DirectConnectorRpcMethodDescriptor::GetIpList,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> DirectConnectorRpc for DirectConnectorRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<
        Descriptor = DirectConnectorRpcDescriptor,
    >,
{
    type Controller = H::Controller;
    async fn get_ip_list(
        &self,
        ctrl: H::Controller,
        input: GetIpListRequest,
    ) -> crate::proto::rpc_types::error::Result<GetIpListResponse> {
        DirectConnectorRpcClient::get_ip_list_inner(self.0.clone(), ctrl, input).await
    }
}
pub struct DirectConnectorRpcClientFactory<
    C: crate::proto::rpc_types::controller::Controller,
>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for DirectConnectorRpcClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory
for DirectConnectorRpcClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = DirectConnectorRpcDescriptor;
    type ClientImpl = Box<dyn DirectConnectorRpc<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(DirectConnectorRpcClient::new(handler))
    }
}
/// A server for a `DirectConnectorRpc`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `DirectConnectorRpc`.
#[derive(Clone, Debug)]
pub struct DirectConnectorRpcServer<A>(
    A,
)
where
    A: DirectConnectorRpc + Clone + Send + 'static;
impl<A> DirectConnectorRpcServer<A>
where
    A: DirectConnectorRpc + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> DirectConnectorRpcServer<A> {
        DirectConnectorRpcServer(service)
    }
    async fn call_inner(
        service: A,
        method: DirectConnectorRpcMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            DirectConnectorRpcMethodDescriptor::GetIpList => {
                let decoded: GetIpListRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.get_ip_list(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor
for DirectConnectorRpcDescriptor {
    type Method = DirectConnectorRpcMethodDescriptor;
    fn name(&self) -> &'static str {
        "DirectConnectorRpc"
    }
    fn proto_name(&self) -> &'static str {
        "DirectConnectorRpc"
    }
    fn package(&self) -> &'static str {
        "peer_rpc"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[DirectConnectorRpcMethodDescriptor::GetIpList]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for DirectConnectorRpcServer<A>
where
    A: DirectConnectorRpc + Clone + Send + Sync + 'static,
{
    type Descriptor = DirectConnectorRpcDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: DirectConnectorRpcMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        DirectConnectorRpcServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor
for DirectConnectorRpcMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            DirectConnectorRpcMethodDescriptor::GetIpList => "get_ip_list",
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            DirectConnectorRpcMethodDescriptor::GetIpList => "GetIpList",
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            DirectConnectorRpcMethodDescriptor::GetIpList => {
                ::std::any::TypeId::of::<GetIpListRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            DirectConnectorRpcMethodDescriptor::GetIpList => ".peer_rpc.GetIpListRequest",
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            DirectConnectorRpcMethodDescriptor::GetIpList => {
                ::std::any::TypeId::of::<GetIpListResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            DirectConnectorRpcMethodDescriptor::GetIpList => {
                ".peer_rpc.GetIpListResponse"
            }
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait UdpHolePunchRpc {
    type Controller: crate::proto::rpc_types::controller::Controller;
    async fn select_punch_listener(
        &self,
        ctrl: Self::Controller,
        input: SelectPunchListenerRequest,
    ) -> crate::proto::rpc_types::error::Result<SelectPunchListenerResponse>;
    /// send packet to one remote_addr, used by nat1-3 to nat1-3
    async fn send_punch_packet_cone(
        &self,
        ctrl: Self::Controller,
        input: SendPunchPacketConeRequest,
    ) -> crate::proto::rpc_types::error::Result<super::common::Void>;
    /// send packet to multiple remote_addr (birthday attack), used by nat4 to nat1-3
    async fn send_punch_packet_hard_sym(
        &self,
        ctrl: Self::Controller,
        input: SendPunchPacketHardSymRequest,
    ) -> crate::proto::rpc_types::error::Result<SendPunchPacketHardSymResponse>;
    async fn send_punch_packet_easy_sym(
        &self,
        ctrl: Self::Controller,
        input: SendPunchPacketEasySymRequest,
    ) -> crate::proto::rpc_types::error::Result<super::common::Void>;
    /// nat4 to nat4 (both predictably)
    async fn send_punch_packet_both_easy_sym(
        &self,
        ctrl: Self::Controller,
        input: SendPunchPacketBothEasySymRequest,
    ) -> crate::proto::rpc_types::error::Result<SendPunchPacketBothEasySymResponse>;
}
/// A service descriptor for a `UdpHolePunchRpc`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct UdpHolePunchRpcDescriptor;
/// Methods available on a `UdpHolePunchRpc`.
///
/// This can be used as a key when routing requests for servers/clients of a `UdpHolePunchRpc`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum UdpHolePunchRpcMethodDescriptor {
    SelectPunchListener = 1,
    /// send packet to one remote_addr, used by nat1-3 to nat1-3
    SendPunchPacketCone = 2,
    /// send packet to multiple remote_addr (birthday attack), used by nat4 to nat1-3
    SendPunchPacketHardSym = 3,
    SendPunchPacketEasySym = 4,
    /// nat4 to nat4 (both predictably)
    SendPunchPacketBothEasySym = 5,
}
impl std::convert::TryFrom<u8> for UdpHolePunchRpcMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(UdpHolePunchRpcMethodDescriptor::SelectPunchListener),
            2 => Ok(UdpHolePunchRpcMethodDescriptor::SendPunchPacketCone),
            3 => Ok(UdpHolePunchRpcMethodDescriptor::SendPunchPacketHardSym),
            4 => Ok(UdpHolePunchRpcMethodDescriptor::SendPunchPacketEasySym),
            5 => Ok(UdpHolePunchRpcMethodDescriptor::SendPunchPacketBothEasySym),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "UdpHolePunchRpc".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `UdpHolePunchRpc`.
///
/// This implements the `UdpHolePunchRpc` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct UdpHolePunchRpcClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> UdpHolePunchRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = UdpHolePunchRpcDescriptor>,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> UdpHolePunchRpcClient<H> {
        UdpHolePunchRpcClient(handler)
    }
}
impl<H> UdpHolePunchRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = UdpHolePunchRpcDescriptor>,
{
    async fn select_punch_listener_inner(
        handler: H,
        ctrl: H::Controller,
        input: SelectPunchListenerRequest,
    ) -> crate::proto::rpc_types::error::Result<SelectPunchListenerResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                UdpHolePunchRpcMethodDescriptor::SelectPunchListener,
                input,
            )
            .await
    }
    async fn send_punch_packet_cone_inner(
        handler: H,
        ctrl: H::Controller,
        input: SendPunchPacketConeRequest,
    ) -> crate::proto::rpc_types::error::Result<super::common::Void> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                UdpHolePunchRpcMethodDescriptor::SendPunchPacketCone,
                input,
            )
            .await
    }
    async fn send_punch_packet_hard_sym_inner(
        handler: H,
        ctrl: H::Controller,
        input: SendPunchPacketHardSymRequest,
    ) -> crate::proto::rpc_types::error::Result<SendPunchPacketHardSymResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                UdpHolePunchRpcMethodDescriptor::SendPunchPacketHardSym,
                input,
            )
            .await
    }
    async fn send_punch_packet_easy_sym_inner(
        handler: H,
        ctrl: H::Controller,
        input: SendPunchPacketEasySymRequest,
    ) -> crate::proto::rpc_types::error::Result<super::common::Void> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                UdpHolePunchRpcMethodDescriptor::SendPunchPacketEasySym,
                input,
            )
            .await
    }
    async fn send_punch_packet_both_easy_sym_inner(
        handler: H,
        ctrl: H::Controller,
        input: SendPunchPacketBothEasySymRequest,
    ) -> crate::proto::rpc_types::error::Result<SendPunchPacketBothEasySymResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                UdpHolePunchRpcMethodDescriptor::SendPunchPacketBothEasySym,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> UdpHolePunchRpc for UdpHolePunchRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = UdpHolePunchRpcDescriptor>,
{
    type Controller = H::Controller;
    async fn select_punch_listener(
        &self,
        ctrl: H::Controller,
        input: SelectPunchListenerRequest,
    ) -> crate::proto::rpc_types::error::Result<SelectPunchListenerResponse> {
        UdpHolePunchRpcClient::select_punch_listener_inner(self.0.clone(), ctrl, input)
            .await
    }
    async fn send_punch_packet_cone(
        &self,
        ctrl: H::Controller,
        input: SendPunchPacketConeRequest,
    ) -> crate::proto::rpc_types::error::Result<super::common::Void> {
        UdpHolePunchRpcClient::send_punch_packet_cone_inner(self.0.clone(), ctrl, input)
            .await
    }
    async fn send_punch_packet_hard_sym(
        &self,
        ctrl: H::Controller,
        input: SendPunchPacketHardSymRequest,
    ) -> crate::proto::rpc_types::error::Result<SendPunchPacketHardSymResponse> {
        UdpHolePunchRpcClient::send_punch_packet_hard_sym_inner(
                self.0.clone(),
                ctrl,
                input,
            )
            .await
    }
    async fn send_punch_packet_easy_sym(
        &self,
        ctrl: H::Controller,
        input: SendPunchPacketEasySymRequest,
    ) -> crate::proto::rpc_types::error::Result<super::common::Void> {
        UdpHolePunchRpcClient::send_punch_packet_easy_sym_inner(
                self.0.clone(),
                ctrl,
                input,
            )
            .await
    }
    async fn send_punch_packet_both_easy_sym(
        &self,
        ctrl: H::Controller,
        input: SendPunchPacketBothEasySymRequest,
    ) -> crate::proto::rpc_types::error::Result<SendPunchPacketBothEasySymResponse> {
        UdpHolePunchRpcClient::send_punch_packet_both_easy_sym_inner(
                self.0.clone(),
                ctrl,
                input,
            )
            .await
    }
}
pub struct UdpHolePunchRpcClientFactory<
    C: crate::proto::rpc_types::controller::Controller,
>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for UdpHolePunchRpcClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory
for UdpHolePunchRpcClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = UdpHolePunchRpcDescriptor;
    type ClientImpl = Box<dyn UdpHolePunchRpc<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(UdpHolePunchRpcClient::new(handler))
    }
}
/// A server for a `UdpHolePunchRpc`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `UdpHolePunchRpc`.
#[derive(Clone, Debug)]
pub struct UdpHolePunchRpcServer<A>(
    A,
)
where
    A: UdpHolePunchRpc + Clone + Send + 'static;
impl<A> UdpHolePunchRpcServer<A>
where
    A: UdpHolePunchRpc + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> UdpHolePunchRpcServer<A> {
        UdpHolePunchRpcServer(service)
    }
    async fn call_inner(
        service: A,
        method: UdpHolePunchRpcMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            UdpHolePunchRpcMethodDescriptor::SelectPunchListener => {
                let decoded: SelectPunchListenerRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.select_punch_listener(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketCone => {
                let decoded: SendPunchPacketConeRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.send_punch_packet_cone(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketHardSym => {
                let decoded: SendPunchPacketHardSymRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.send_punch_packet_hard_sym(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketEasySym => {
                let decoded: SendPunchPacketEasySymRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.send_punch_packet_easy_sym(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketBothEasySym => {
                let decoded: SendPunchPacketBothEasySymRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.send_punch_packet_both_easy_sym(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor
for UdpHolePunchRpcDescriptor {
    type Method = UdpHolePunchRpcMethodDescriptor;
    fn name(&self) -> &'static str {
        "UdpHolePunchRpc"
    }
    fn proto_name(&self) -> &'static str {
        "UdpHolePunchRpc"
    }
    fn package(&self) -> &'static str {
        "peer_rpc"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[
            UdpHolePunchRpcMethodDescriptor::SelectPunchListener,
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketCone,
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketHardSym,
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketEasySym,
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketBothEasySym,
        ]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for UdpHolePunchRpcServer<A>
where
    A: UdpHolePunchRpc + Clone + Send + Sync + 'static,
{
    type Descriptor = UdpHolePunchRpcDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: UdpHolePunchRpcMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        UdpHolePunchRpcServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor
for UdpHolePunchRpcMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            UdpHolePunchRpcMethodDescriptor::SelectPunchListener => {
                "select_punch_listener"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketCone => {
                "send_punch_packet_cone"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketHardSym => {
                "send_punch_packet_hard_sym"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketEasySym => {
                "send_punch_packet_easy_sym"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketBothEasySym => {
                "send_punch_packet_both_easy_sym"
            }
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            UdpHolePunchRpcMethodDescriptor::SelectPunchListener => "SelectPunchListener",
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketCone => "SendPunchPacketCone",
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketHardSym => {
                "SendPunchPacketHardSym"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketEasySym => {
                "SendPunchPacketEasySym"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketBothEasySym => {
                "SendPunchPacketBothEasySym"
            }
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            UdpHolePunchRpcMethodDescriptor::SelectPunchListener => {
                ::std::any::TypeId::of::<SelectPunchListenerRequest>()
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketCone => {
                ::std::any::TypeId::of::<SendPunchPacketConeRequest>()
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketHardSym => {
                ::std::any::TypeId::of::<SendPunchPacketHardSymRequest>()
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketEasySym => {
                ::std::any::TypeId::of::<SendPunchPacketEasySymRequest>()
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketBothEasySym => {
                ::std::any::TypeId::of::<SendPunchPacketBothEasySymRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            UdpHolePunchRpcMethodDescriptor::SelectPunchListener => {
                ".peer_rpc.SelectPunchListenerRequest"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketCone => {
                ".peer_rpc.SendPunchPacketConeRequest"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketHardSym => {
                ".peer_rpc.SendPunchPacketHardSymRequest"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketEasySym => {
                ".peer_rpc.SendPunchPacketEasySymRequest"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketBothEasySym => {
                ".peer_rpc.SendPunchPacketBothEasySymRequest"
            }
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            UdpHolePunchRpcMethodDescriptor::SelectPunchListener => {
                ::std::any::TypeId::of::<SelectPunchListenerResponse>()
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketCone => {
                ::std::any::TypeId::of::<super::common::Void>()
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketHardSym => {
                ::std::any::TypeId::of::<SendPunchPacketHardSymResponse>()
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketEasySym => {
                ::std::any::TypeId::of::<super::common::Void>()
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketBothEasySym => {
                ::std::any::TypeId::of::<SendPunchPacketBothEasySymResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            UdpHolePunchRpcMethodDescriptor::SelectPunchListener => {
                ".peer_rpc.SelectPunchListenerResponse"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketCone => ".common.Void",
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketHardSym => {
                ".peer_rpc.SendPunchPacketHardSymResponse"
            }
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketEasySym => ".common.Void",
            UdpHolePunchRpcMethodDescriptor::SendPunchPacketBothEasySym => {
                ".peer_rpc.SendPunchPacketBothEasySymResponse"
            }
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
#[async_trait::async_trait]
#[auto_impl::auto_impl(&, Arc, Box)]
pub trait PeerCenterRpc {
    type Controller: crate::proto::rpc_types::controller::Controller;
    async fn report_peers(
        &self,
        ctrl: Self::Controller,
        input: ReportPeersRequest,
    ) -> crate::proto::rpc_types::error::Result<ReportPeersResponse>;
    async fn get_global_peer_map(
        &self,
        ctrl: Self::Controller,
        input: GetGlobalPeerMapRequest,
    ) -> crate::proto::rpc_types::error::Result<GetGlobalPeerMapResponse>;
}
/// A service descriptor for a `PeerCenterRpc`.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Default)]
pub struct PeerCenterRpcDescriptor;
/// Methods available on a `PeerCenterRpc`.
///
/// This can be used as a key when routing requests for servers/clients of a `PeerCenterRpc`.
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum PeerCenterRpcMethodDescriptor {
    ReportPeers = 1,
    GetGlobalPeerMap = 2,
}
impl std::convert::TryFrom<u8> for PeerCenterRpcMethodDescriptor {
    type Error = crate::proto::rpc_types::error::Error;
    fn try_from(value: u8) -> crate::proto::rpc_types::error::Result<Self> {
        match value {
            1 => Ok(PeerCenterRpcMethodDescriptor::ReportPeers),
            2 => Ok(PeerCenterRpcMethodDescriptor::GetGlobalPeerMap),
            _ => {
                Err(
                    crate::proto::rpc_types::error::Error::InvalidMethodIndex(
                        value,
                        "PeerCenterRpc".to_string(),
                    ),
                )
            }
        }
    }
}
/// A client for a `PeerCenterRpc`.
///
/// This implements the `PeerCenterRpc` trait by dispatching all method calls to the supplied `Handler`.
#[derive(Clone, Debug)]
pub struct PeerCenterRpcClient<H>(
    H,
)
where
    H: crate::proto::rpc_types::handler::Handler;
impl<H> PeerCenterRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = PeerCenterRpcDescriptor>,
{
    /// Creates a new client instance that delegates all method calls to the supplied handler.
    pub fn new(handler: H) -> PeerCenterRpcClient<H> {
        PeerCenterRpcClient(handler)
    }
}
impl<H> PeerCenterRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = PeerCenterRpcDescriptor>,
{
    async fn report_peers_inner(
        handler: H,
        ctrl: H::Controller,
        input: ReportPeersRequest,
    ) -> crate::proto::rpc_types::error::Result<ReportPeersResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                PeerCenterRpcMethodDescriptor::ReportPeers,
                input,
            )
            .await
    }
    async fn get_global_peer_map_inner(
        handler: H,
        ctrl: H::Controller,
        input: GetGlobalPeerMapRequest,
    ) -> crate::proto::rpc_types::error::Result<GetGlobalPeerMapResponse> {
        crate::proto::rpc_types::__rt::call_method(
                handler,
                ctrl,
                PeerCenterRpcMethodDescriptor::GetGlobalPeerMap,
                input,
            )
            .await
    }
}
#[async_trait::async_trait]
impl<H> PeerCenterRpc for PeerCenterRpcClient<H>
where
    H: crate::proto::rpc_types::handler::Handler<Descriptor = PeerCenterRpcDescriptor>,
{
    type Controller = H::Controller;
    async fn report_peers(
        &self,
        ctrl: H::Controller,
        input: ReportPeersRequest,
    ) -> crate::proto::rpc_types::error::Result<ReportPeersResponse> {
        PeerCenterRpcClient::report_peers_inner(self.0.clone(), ctrl, input).await
    }
    async fn get_global_peer_map(
        &self,
        ctrl: H::Controller,
        input: GetGlobalPeerMapRequest,
    ) -> crate::proto::rpc_types::error::Result<GetGlobalPeerMapResponse> {
        PeerCenterRpcClient::get_global_peer_map_inner(self.0.clone(), ctrl, input).await
    }
}
pub struct PeerCenterRpcClientFactory<
    C: crate::proto::rpc_types::controller::Controller,
>(
    std::marker::PhantomData<C>,
);
impl<C: crate::proto::rpc_types::controller::Controller> Clone
for PeerCenterRpcClientFactory<C> {
    fn clone(&self) -> Self {
        Self(std::marker::PhantomData)
    }
}
impl<C> crate::proto::rpc_types::__rt::RpcClientFactory for PeerCenterRpcClientFactory<C>
where
    C: crate::proto::rpc_types::controller::Controller,
{
    type Descriptor = PeerCenterRpcDescriptor;
    type ClientImpl = Box<dyn PeerCenterRpc<Controller = C> + Send + 'static>;
    type Controller = C;
    fn new(
        handler: impl crate::proto::rpc_types::handler::Handler<
            Descriptor = Self::Descriptor,
            Controller = Self::Controller,
        >,
    ) -> Self::ClientImpl {
        Box::new(PeerCenterRpcClient::new(handler))
    }
}
/// A server for a `PeerCenterRpc`.
///
/// This implements the `Server` trait by handling requests and dispatch them to methods on the
/// supplied `PeerCenterRpc`.
#[derive(Clone, Debug)]
pub struct PeerCenterRpcServer<A>(
    A,
)
where
    A: PeerCenterRpc + Clone + Send + 'static;
impl<A> PeerCenterRpcServer<A>
where
    A: PeerCenterRpc + Clone + Send + 'static,
{
    /// Creates a new server instance that dispatches all calls to the supplied service.
    pub fn new(service: A) -> PeerCenterRpcServer<A> {
        PeerCenterRpcServer(service)
    }
    async fn call_inner(
        service: A,
        method: PeerCenterRpcMethodDescriptor,
        ctrl: A::Controller,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        match method {
            PeerCenterRpcMethodDescriptor::ReportPeers => {
                let decoded: ReportPeersRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.report_peers(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
            PeerCenterRpcMethodDescriptor::GetGlobalPeerMap => {
                let decoded: GetGlobalPeerMapRequest = crate::proto::rpc_types::__rt::decode(
                    input,
                )?;
                let ret = service.get_global_peer_map(ctrl, decoded).await?;
                crate::proto::rpc_types::__rt::encode(ret)
            }
        }
    }
}
impl crate::proto::rpc_types::descriptor::ServiceDescriptor for PeerCenterRpcDescriptor {
    type Method = PeerCenterRpcMethodDescriptor;
    fn name(&self) -> &'static str {
        "PeerCenterRpc"
    }
    fn proto_name(&self) -> &'static str {
        "PeerCenterRpc"
    }
    fn package(&self) -> &'static str {
        "peer_rpc"
    }
    fn methods(&self) -> &'static [Self::Method] {
        &[
            PeerCenterRpcMethodDescriptor::ReportPeers,
            PeerCenterRpcMethodDescriptor::GetGlobalPeerMap,
        ]
    }
}
#[async_trait::async_trait]
impl<A> crate::proto::rpc_types::handler::Handler for PeerCenterRpcServer<A>
where
    A: PeerCenterRpc + Clone + Send + Sync + 'static,
{
    type Descriptor = PeerCenterRpcDescriptor;
    type Controller = A::Controller;
    async fn call(
        &self,
        ctrl: A::Controller,
        method: PeerCenterRpcMethodDescriptor,
        input: ::bytes::Bytes,
    ) -> crate::proto::rpc_types::error::Result<::bytes::Bytes> {
        PeerCenterRpcServer::call_inner(self.0.clone(), method, ctrl, input).await
    }
}
impl crate::proto::rpc_types::descriptor::MethodDescriptor
for PeerCenterRpcMethodDescriptor {
    fn name(&self) -> &'static str {
        match *self {
            PeerCenterRpcMethodDescriptor::ReportPeers => "report_peers",
            PeerCenterRpcMethodDescriptor::GetGlobalPeerMap => "get_global_peer_map",
        }
    }
    fn proto_name(&self) -> &'static str {
        match *self {
            PeerCenterRpcMethodDescriptor::ReportPeers => "ReportPeers",
            PeerCenterRpcMethodDescriptor::GetGlobalPeerMap => "GetGlobalPeerMap",
        }
    }
    fn input_type(&self) -> ::std::any::TypeId {
        match *self {
            PeerCenterRpcMethodDescriptor::ReportPeers => {
                ::std::any::TypeId::of::<ReportPeersRequest>()
            }
            PeerCenterRpcMethodDescriptor::GetGlobalPeerMap => {
                ::std::any::TypeId::of::<GetGlobalPeerMapRequest>()
            }
        }
    }
    fn input_proto_type(&self) -> &'static str {
        match *self {
            PeerCenterRpcMethodDescriptor::ReportPeers => ".peer_rpc.ReportPeersRequest",
            PeerCenterRpcMethodDescriptor::GetGlobalPeerMap => {
                ".peer_rpc.GetGlobalPeerMapRequest"
            }
        }
    }
    fn output_type(&self) -> ::std::any::TypeId {
        match *self {
            PeerCenterRpcMethodDescriptor::ReportPeers => {
                ::std::any::TypeId::of::<ReportPeersResponse>()
            }
            PeerCenterRpcMethodDescriptor::GetGlobalPeerMap => {
                ::std::any::TypeId::of::<GetGlobalPeerMapResponse>()
            }
        }
    }
    fn output_proto_type(&self) -> &'static str {
        match *self {
            PeerCenterRpcMethodDescriptor::ReportPeers => ".peer_rpc.ReportPeersResponse",
            PeerCenterRpcMethodDescriptor::GetGlobalPeerMap => {
                ".peer_rpc.GetGlobalPeerMapResponse"
            }
        }
    }
    fn index(&self) -> u8 {
        *self as u8
    }
}
